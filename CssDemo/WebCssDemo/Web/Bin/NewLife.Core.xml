<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NewLife.Core</name>
    </assembly>
    <members>
        <member name="T:NewLife.Xml.XmlConfig`1">
            <summary>Xml配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Xml.XmlConfigFileAttribute"/>特性指定配置文件路径以及自动更新时间。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            
            考虑到自动刷新，不提供LoadFile和SaveFile等方法，可通过扩展方法ToXmlFileEntity和ToXmlFile实现。
            
            用户也可以通过配置实体类的静态构造函数修改基类的<see cref="P:NewLife.Xml.XmlConfig`1._.ConfigFile"/>和<see cref="P:NewLife.Xml.XmlConfig`1._.ReloadTime"/>来动态配置加载信息。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.lastWrite">
            <summary>最后写入时间</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.expire">
            <summary>过期时间。如果在这个时间之后再次访问，将检查文件修改时间</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1._">
            <summary>一些设置。派生类可以在自己的静态构造函数中指定</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ConfigFile">
            <summary>配置文件路径</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="T:NewLife.Web.HttpState`1">
            <summary>Http状态，经常用于登录用户的Current</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:NewLife.Web.HttpState`1.EntityToCookie">
            <summary>实体转为Cookie的方法</summary>
        </member>
        <member name="F:NewLife.Web.HttpState`1.CookieToEntity">
            <summary>Cookie转为实体的方法</summary>
        </member>
        <member name="F:NewLife.Web.HttpState`1.Save">
            <summary>自定义保存</summary>
        </member>
        <member name="F:NewLife.Web.HttpState`1.Load">
            <summary>自定义加载</summary>
        </member>
        <member name="M:NewLife.Web.HttpState`1.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Web.HttpState`1.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Get(System.Converter{System.Web.HttpCookie,`0})">
            <summary>获取Http状态</summary>
            <param name="conv">把Cookie转为实体的转换器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Get(System.Converter{System.Web.HttpCookie,`0},System.Converter{NewLife.Web.HttpState{`0},`0})">
            <summary>获取Http状态</summary>
            <param name="conv">把Cookie转为实体的转换器</param>
            <param name="load">自定义加载方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Set(`0,System.Converter{`0,System.Web.HttpCookie})">
            <summary>设置Http状态</summary>
            <param name="entity"></param>
            <param name="conv">把实体转换为Cookie的转换器</param>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Set(`0,System.Converter{`0,System.Web.HttpCookie},System.Converter{`0,System.Boolean})">
            <summary>设置Http状态</summary>
            <param name="entity">实体</param>
            <param name="conv">把实体转换为Cookie的转换器</param>
            <param name="save">自定义保存</param>
        </member>
        <member name="M:NewLife.Web.HttpState`1.GetCache(System.String)">
            <summary>从全局Cache中获取数据</summary>
            <param name="sessionID">使用SessionID作为数据在全局Cache中的标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.HttpState`1.SetCache(System.String,`0)">
            <summary>设置数据到全局Cache</summary>
            <param name="sessionID">使用SessionID作为数据在全局Cache中的标识</param>
            <param name="entity"></param>
        </member>
        <member name="P:NewLife.Web.HttpState`1.Key">
            <summary>键值</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableSession">
            <summary>使用Session</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableHttpItems">
            <summary>使用HttpItems</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableCache">
            <summary>使用Cache</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableCookie">
            <summary>使用Cookie</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.Http">
            <summary>Http上下文</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.Current">
            <summary>获取当前Http状态保存的对象</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonWriter">
            <summary>Json写入器</summary>
        </member>
        <member name="T:NewLife.Serialization.TextWriterBase`1">
            <summary>文本写入器基类</summary>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.WriterBase`1">
            <summary>写入器基类</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接写入，自定义类型反射得到成员，逐层递归写入！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            
            序列化框架的处理顺序为：<see cref="T:NewLife.Serialization.IAccessor"/>接口 =&gt; <see cref="E:NewLife.Serialization.WriterBase`1.OnObjectWriting"/>事件 =&gt; 扩展类型 =&gt; <see cref="M:NewLife.Serialization.WriterBase`1.WriteValue(System.Object)"/>基础类型 =&gt; <see cref="M:NewLife.Serialization.WriterBase`1.WriteDictionary(System.Collections.IDictionary,System.Type,NewLife.Serialization.WriteObjectCallback)"/>字典 =&gt; <see cref="M:NewLife.Serialization.WriterBase`1.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)"/>枚举 =&gt; <see cref="M:NewLife.Serialization.WriterBase`1.WriteSerializable(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)"/>序列化接口 =&gt; <see cref="M:NewLife.Serialization.WriterBase`1.WriteCustomObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)"/>自定义对象 =&gt; <see cref="M:NewLife.Serialization.WriterBase`1.WriteUnKnown(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)"/>未知类型 =&gt; <see cref="E:NewLife.Serialization.WriterBase`1.OnObjectWrited"/>事件
            
            序列化对象时只能调用<see cref="M:NewLife.Serialization.WriterBase`1.WriteObject(System.Object)"/>方法，其它所有方法（包括所有Write重载）仅用于内部写入或者自定义序列化时使用。
            
            Decimal转为四个Int32整数输出；
            DateTime转为Int64输出。
            </remarks>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterBase`1">
            <summary>读写器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.IReaderWriter">
            <summary>读写器接口</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接写入，自定义类型反射得到成员，逐层递归写入！
            
            <see cref="P:NewLife.Serialization.IReaderWriter.Stream"/>作为序列化操作的根本，读写都是对数据流进行操作；
            <see cref="P:NewLife.Serialization.IReaderWriter.Settings"/>是序列化时的一些设置；
            <see cref="P:NewLife.Serialization.IReaderWriter.Depth"/>表示当前序列化的层次；
            <see cref="M:NewLife.Serialization.IReaderWriter.GetMembers(System.Type,System.Object)"/>方法和<see cref="E:NewLife.Serialization.IReaderWriter.OnGotMembers"/>事件用于获取/修改自定义类型需要序列化的成员，默认反射实现。
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.Reset">
            <summary>重置</summary>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.GetMembers(System.Type,System.Object)">
            <summary>获取需要序列化的成员</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.EnableTraceStream">
            <summary>使用跟踪流。实际上是重新包装一次Stream，必须在设置Stream，使用之前</summary>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.WriteLog(System.String,System.Object[])">
            <summary>调试输出</summary>
            <param name="action">操作</param>
            <param name="args">参数</param>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Name">
            <summary>读写器名称</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Settings">
            <summary>序列化设置</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Depth">
            <summary>层次深度。</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.CurrentObject">
            <summary>当前对象</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.CurrentMember">
            <summary>当前成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Items">
            <summary>用于存放使用者的上下文数据</summary>
        </member>
        <member name="E:NewLife.Serialization.IReaderWriter.OnGotMembers">
            <summary>获取指定类型中需要序列化的成员时触发。使用者可以修改、排序要序列化的成员。</summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.Reset">
            <summary>重置</summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.IsExactType(System.Type)">
            <summary>是否精确类型</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.GetMembers(System.Type,System.Object)">
            <summary>获取需要序列化的成员</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.OnGetMembers(System.Type,System.Object)">
            <summary>获取需要序列化的成员（属性或字段）</summary>
            <param name="type">指定类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.ToString">
            <summary>已重载。增加输出设置信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.EnableTraceStream">
            <summary>使用跟踪流。实际上是重新包装一次Stream，必须在设置Stream，使用之前</summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.ShowMembers(System.String,NewLife.Serialization.IObjectMemberInfo[])">
            <summary>显示成员列表</summary>
            <param name="action"></param>
            <param name="members"></param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.WriteLog(System.String,System.Object[])">
            <summary>调试输出</summary>
            <param name="action">操作</param>
            <param name="args">参数</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.WriteLog(System.Int32,System.String,System.Object[])">
            <summary>调试输出</summary>
            <param name="colorIndex">颜色方案</param>
            <param name="action">操作</param>
            <param name="args">参数</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.SetDebugIndent(System.Int32)">
            <summary>设置调试缩进</summary>
            <param name="indent">缩进</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.SetDebugIndent">
            <summary>设置调试缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Name">
            <summary>读写器名称</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Stream">
            <summary>数据流。默认实例化一个MemoryStream，设置值时将重置Depth为1</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Settings">
            <summary>序列化设置</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.NewLife#Serialization#IReaderWriter#Settings">
            <summary>序列化设置</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Depth">
            <summary>层次深度</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.UseSize">
            <summary>是否使用大小，如果使用，将在写入数组、集合和字符串前预先写入大小</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.CurrentObject">
            <summary>当前对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.CurrentMember">
            <summary>当前成员</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Items">
            <summary>用于存放使用者的上下文数据</summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderWriterBase`1.OnGotMembers">
            <summary>获取指定类型中需要序列化的成员时触发。使用者可以修改、排序要序列化的成员。</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.IsConsole">
            <summary>是否控制台</summary>
        </member>
        <member name="T:NewLife.Serialization.IWriter2">
            <summary>不需要写名称的写入接口。主要指二进制序列化</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接写入，自定义类型反射得到成员，逐层递归写入！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            </remarks>
        </member>
        <member name="T:NewLife.Serialization.IWriter">
            <summary>写入器接口</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接写入，自定义类型反射得到成员，逐层递归写入！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            
            序列化对象时只能调用<see cref="M:NewLife.Serialization.IWriter.WriteObject(System.Object)"/>方法，其它所有方法（包括所有Write重载）仅用于内部写入或者自定义序列化时使用。
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteObject(System.Object)">
            <summary>主要入口方法。把对象写入数据流</summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>主要入口方法。写入对象。具体读写器可以重载该方法以修改写入对象前后的行为。</summary>
            <param name="value">对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteMember(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入对象成员</summary>
            <param name="name">成员名字</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的成员类型</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Flush">
            <summary>刷新缓存中的数据</summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnObjectWriting">
            <summary>写对象前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnObjectWrited">
            <summary>写对象后触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnMemberWriting">
            <summary>写成员前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnMemberWrited">
            <summary>写成员后触发。</summary>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Byte)">
            <summary>将一个无符号字节写入</summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Byte[])">
            <summary>将字节数组写入，如果设置了UseSize，则先写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.SByte)">
            <summary>将一个有符号字节写入当前流，并将流的位置提升 1 个字节。</summary>
            <param name="value">要写入的有符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.UInt16)">
            <summary>将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.UInt32)">
            <summary>将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.UInt64)">
            <summary>将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Single)">
            <summary>将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Double)">
            <summary>将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Char)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Char[])">
            <summary>将字符数组写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Boolean)">
            <summary>将单字节 Boolean 值写入</summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Decimal)">
            <summary>将一个十进制值写入当前流，并将流位置提升十六个字节。</summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.DateTime)">
            <summary>将一个时间日期写入</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Net.IPAddress)">
            <summary>写入IPAddress</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Net.IPEndPoint)">
            <summary>写入IPEndPoint</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Type)">
            <summary>写入Type</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.WriteName(System.String)">
            <summary>写入成员名称</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.WriteValue(System.Object)">
            <summary>写入值类型</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.Write(System.Guid)">
            <summary>写入Guid</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter2.WriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte)">
            <summary>将一个无符号字节写入</summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte[])">
            <summary>将字节数组写入，如果设置了UseSize，则先写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.SByte)">
            <summary>将一个有符号字节写入当前流，并将流的位置提升 1 个字节。</summary>
            <param name="value">要写入的有符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.UInt16)">
            <summary>将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.UInt32)">
            <summary>将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.UInt64)">
            <summary>将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Single)">
            <summary>将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Double)">
            <summary>将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Char)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Char[])">
            <summary>将字符数组写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Boolean)">
            <summary>将单字节 Boolean 值写入</summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Decimal)">
            <summary>将一个十进制值写入当前流，并将流位置提升十六个字节。</summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.DateTime)">
            <summary>将一个时间日期写入</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteName(System.String)">
            <summary>写入成员名称</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteValue(System.Object)">
            <summary>写入值类型</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteValue(System.Object,System.Type)">
            <summary>写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Guid)">
            <summary>写入Guid</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Collections.IDictionary)">
            <summary>写入枚举类型数据</summary>
            <param name="value">枚举数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteDictionary(System.Collections.IDictionary,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入字典类型数据</summary>
            <param name="value">字典数据</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入字典项</summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.GetDictionaryEntryType(System.Type,System.Type@,System.Type@)">
            <summary>取得字典的键值类型，默认只支持获取两个泛型参数的字典的键值类型</summary>
            <param name="type">字典类型</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <returns>是否获取成功，如果失败，则字典读取失败</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Collections.IEnumerable)">
            <summary>写入枚举类型数据</summary>
            <param name="value">枚举数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举数据，复杂类型使用委托方法进行处理</summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举项</summary>
            <param name="value">对象</param>
            <param name="type">元素类型</param>
            <param name="index">元素索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteSerializable(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入实现了可序列化接口的对象</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteUnKnown(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteExtend(System.Object,System.Type)">
            <summary>扩展写入，反射查找合适的写入方法</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Net.IPAddress)">
            <summary>写入IPAddress</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Net.IPAddress)">
            <summary>写入IPAddress</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Net.IPEndPoint)">
            <summary>写入IPEndPoint</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Net.IPEndPoint)">
            <summary>写入IPEndPoint</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Type)">
            <summary>写入Type</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Type)">
            <summary>写入Type</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteType(System.Type)">
            <summary>写入Type</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.CheckAndWriteType(System.String,System.Object,System.Type)">
            <summary>检查对象类型与指定写入类型是否一致</summary>
            <remarks>
            检查对象类型与指定写入类型是否一致，若不一致，则先写入类型，以保证读取的时候能够以正确的类型读取。同时返回对象实际类型。
            若想不写对象类型，可以提前设定精确类型。
            </remarks>
            <param name="action"></param>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObjectType(System.Type)">
            <summary>写对象类型</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObject(System.Object)">
            <summary>主要入口方法。把对象写入数据流</summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>主要入口方法。</summary>
            <remarks>把目标对象指定成员写入数据流，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员</remarks>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>把目标对象指定成员写入数据流，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteRefObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入引用对象</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObjRef(System.Object)">
            <summary>写入对象引用。</summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteObjRefIndex(System.Int32)">
            <summary>写对象引用计数</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteCustomObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写自定义对象</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteMember(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入对象成员</summary>
            <param name="name">成员名字</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的成员类型</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteMember(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入对象成员</summary>
            <param name="name">成员名字</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的成员类型</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteLengths(System.String)">
            <summary>写入长度。多维数组用</summary>
            <param name="lengths"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Flush">
            <summary>刷新缓存中的数据</summary>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.AutoFlush">
            <summary>如果设置了自动刷新缓存，该方面将会调用Flush</summary>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Reset">
            <summary>重置</summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnObjectWriting">
            <summary>写对象前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnObjectWrited">
            <summary>写对象后触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnMemberWriting">
            <summary>写成员前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnMemberWrited">
            <summary>写成员后触发。</summary>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Byte)">
            <summary>将一个无符号字节写入</summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Byte[])">
            <summary>将字节数组以[0xff,0xff,0xff]的格式写入</summary>
            <param name="buffer"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.SByte)">
            <summary>将一个有符号字节写入当前流，并将流的位置提升 1 个字节。</summary>
            <param name="value">要写入的有符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.UInt16)">
            <summary>将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.UInt32)">
            <summary>将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.UInt64)">
            <summary>将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Single)">
            <summary>将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Double)">
            <summary>将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.WriteLiteral(System.String)">
            <summary>输出字符串字面值,不做编码处理</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.OnWriteLiteral(System.String)">
            <summary>输出字符串字面值,不做编码处理</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.WriteNull">
            <summary>输出空</summary>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Boolean)">
            <summary>将单字节 Boolean 值写入</summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Decimal)">
            <summary>将一个十进制值写入当前流，并将流位置提升十六个字节。</summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Guid)">
            <summary>写入Guid</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.OnWrite(System.Net.IPAddress)">
            <summary>写入IPAddress</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.OnWrite(System.Net.IPEndPoint)">
            <summary>写入IPEndPoint</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.WriteValue(System.Object,System.Type)">
            <summary>写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.ToStr">
            <summary>把数据流转为字符串</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.TextWriterBase`1.UseSize">
            <summary>是否使用大小，如果使用，将在写入数组、集合和字符串前预先写入大小。字符串类型读写器一般带有边界，不需要使用大小</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.#ctor">
            <summary>构造方法</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.DateTime)">
            <summary>将一个时间日期写入</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteLiteral(System.String)">
            <summary>输出字符串字面值,不做编码处理</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteNull">
            <summary>输出空</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Char)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Char[])">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="chars"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="chars"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.JavascriptStringEncode(System.String)">
            <summary>将指定字符串编码成json中表示的字符串,将编码Unicode字符为\uXXXX</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.JavascriptStringEncode(System.String,System.Boolean)">
            <summary>将指定字符串编码成javascript的字面字符串(即写入到js代码中的和value内容相同的代码),开始和结尾不包含双引号</summary>
            <param name="value">要编码的字符串,value为null时返回""</param>
            <param name="encodeUnicode">是否将Unicode字符编码为\uXXXX的格式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举数据，复杂类型使用委托方法进行处理</summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举项</summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Slice``1(``0[],System.Int32,System.Int32)">
            <summary>返回指定数组的一个片段,始终返回的是array参数的一个副本</summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteDictionary(System.Collections.IDictionary,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>将字典类型数据写入到当前流位置</summary>
            <param name="value"></param>
            <param name="type"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入字典键和值</summary>
            <param name="value"></param>
            <param name="keyType"></param>
            <param name="valueType"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter.writeValueType">
            <summary>是否需要写入值类型信息的标志,为null时表示不需要,非null时并且等于待写入的值时写入值类型</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter.ComplexObjectDepth">
            <summary>写入的复合对象深度,指使用{} []包括的深度</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter.WriteMemberCount">
            <summary>是否写入成员的计数器,用于控制换行输出</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteObjectType(System.Type)">
            <summary>JsonWriter的对象类型由writeValueType写入,作为第一个成员,所以不需要</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入对象。具体读写器可以重载该方法以修改写入对象前后的行为。</summary>
            <param name="value">对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteCustomObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写对象成员</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteMember(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入成员</summary>
            <param name="name">成员名字</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的成员类型</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.ComplexObjectDepthIsOverflow">
            <summary>当前解析复合对象深度是否超出,用于避免循环引用可能引起的堆栈溢出,仅在Settings.RepeatedActionType是RepeatedAction.DepthLimit时才可能返回true</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Flush">
            <summary>刷新缓存中的数据</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Stream">
            <summary>数据流。更改数据流后，重置Writer为空，以使用新的数据流</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader">
            <summary>Json读取器</summary>
        </member>
        <member name="T:NewLife.Serialization.TextReaderBase`1">
            <summary>文本读取器基类</summary>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.ReaderBase`1">
            <summary>读取器基类</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接读取，自定义类型反射得到成员，逐层递归读取！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            
            序列化框架的处理顺序为：<see cref="T:NewLife.Serialization.IAccessor"/>接口 =&gt; <see cref="E:NewLife.Serialization.ReaderBase`1.OnObjectReading"/>事件 =&gt; 扩展类型 =&gt; <see cref="M:NewLife.Serialization.ReaderBase`1.ReadValue(System.Type,System.Object@)"/>基础类型 =&gt; <see cref="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Object@)"/>字典 =&gt; <see cref="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Object@)"/>枚举 =&gt; <see cref="M:NewLife.Serialization.ReaderBase`1.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)"/>序列化接口 =&gt; <see cref="M:NewLife.Serialization.ReaderBase`1.ReadCustomObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)"/>自定义对象 =&gt; <see cref="M:NewLife.Serialization.ReaderBase`1.ReadUnKnown(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)"/>未知类型 =&gt; <see cref="E:NewLife.Serialization.ReaderBase`1.OnObjectReaded"/>事件
            
            反序列化对象时只能调用<see cref="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type)"/>方法，其它所有方法（包括所有Read重载）仅用于内部读取或者自定义序列化时使用。
            </remarks>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.IReader2">
            <summary>读取器接口</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接读取，自定义类型反射得到成员，逐层递归读取！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            </remarks>
        </member>
        <member name="T:NewLife.Serialization.IReader">
            <summary>读取器接口</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接读取，自定义类型反射得到成员，逐层递归读取！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            
            反序列化对象时只能调用<see cref="M:NewLife.Serialization.IReader.ReadObject(System.Type)"/>方法，其它所有方法（包括所有Read重载）仅用于内部读取或者自定义序列化时使用。
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadObject(System.Type)">
            <summary>主要入口方法。从数据流中读取指定类型的对象</summary>
            <param name="type">类型</param>
            <returns>对象</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadObject``1">
            <summary>主要入口方法。从数据流中读取指定类型的对象</summary>
            <typeparam name="T">类型</typeparam>
            <returns>对象</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>主要入口方法。尝试按照指定类型读取目标对象</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取对象成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnObjectReading">
            <summary>读对象前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnObjectReaded">
            <summary>读对象后触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnMemberReading">
            <summary>读成员前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnMemberReaded">
            <summary>读成员后触发。</summary>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadByte">
            <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadSByte">
            <summary>从此流中读取一个有符号字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadUInt16">
            <summary>使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadUInt32">
            <summary>从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadUInt64">
            <summary>从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadSingle">
            <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadDouble">
            <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadChar">
            <summary>从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadString">
            <summary>从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadBoolean">
            <summary>从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadDecimal">
            <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadDateTime">
            <summary>读取一个时间日期</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadValue(System.Type)">
            <summary>读取值类型数据</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadValue(System.Type,System.Object@)">
            <summary>尝试读取值类型数据，返回是否读取成功</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadGuid">
            <summary>读取Guid</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadIPAddress">
            <summary>读取IPAddress</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadIPEndPoint">
            <summary>读取IPEndPoint</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadType">
            <summary>读取Type</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadObjRef(System.Type,System.Object@,System.Int32@)">
            <summary>读取对象引用。</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="index">引用计数</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader2.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadByte">
            <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSByte">
            <summary>从此流中读取一个有符号字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadIntBytes(System.Int32)">
            <summary>读取整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUInt16">
            <summary>使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUInt32">
            <summary>从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUInt64">
            <summary>从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSingle">
            <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDouble">
            <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadChar">
            <summary>从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadString">
            <summary>从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadBoolean">
            <summary>从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDecimal">
            <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDateTime">
            <summary>读取一个时间日期</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadValue(System.Type)">
            <summary>读取值类型数据</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadValue(System.Type,System.Object@)">
            <summary>尝试读取值类型数据，返回是否读取成功</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadGuid">
            <summary>读取Guid</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Object@)">
            <summary>尝试读取字典类型对象</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取字典类型对象</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Type,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取字典项集合，以读取键值失败作为读完字典项的标识，子类可以重载实现以字典项数量来读取</summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="count">元素个数</param>
            <param name="callback">处理元素的方法</param>
            <returns>字典项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取字典项</summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="value">字典项</param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GetDictionaryEntryType(System.Type,System.Type@,System.Type@)">
            <summary>取得字典的键值类型，默认只支持获取两个泛型参数的字典的键值类型</summary>
            <param name="type">字典类型</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <returns>是否获取成功，如果失败，则字典读取失败</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Object@)">
            <summary>尝试读取枚举</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取枚举</summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取枚举</summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">类型</param>
            <param name="elementType">元素类型数组</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadItems(System.Type,System.Type,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取元素集合</summary>
            <param name="type"></param>
            <param name="elementType"></param>
            <param name="count">元素个数</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取项</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ProcessItems(System.Type,System.Type,System.Object@,System.Collections.IList)">
            <summary>处理结果集</summary>
            <param name="type"></param>
            <param name="elementType"></param>
            <param name="value"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取实现了可序列化接口的对象</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUnKnown(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadExtend(System.Type,System.Object@)">
            <summary>扩展读取，反射查找合适的读取方法</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadIPAddress">
            <summary>读取IPAddress</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadIPAddress">
            <summary>读取IPAddress</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadIPEndPoint">
            <summary>读取IPEndPoint</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadIPEndPoint">
            <summary>读取IPEndPoint</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadType">
            <summary>读取Type</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadType">
            <summary>读取Type</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.CheckAndReadType(System.String,System.Type,System.Object)">
            <summary>检查对象类型与指定写入类型是否一致，若不一致，则先写入类型，以保证读取的时候能够以正确的类型读取。</summary>
            <param name="action"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns>返回对象实际类型。</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GuessType(System.Type)">
            <summary>猜测类型。对于无法读取到对象类型的类型，并且是接口之类的，可以猜测</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObjectType">
            <summary>读对象类型</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type)">
            <summary>主要入口方法。从数据流中读取指定类型的对象</summary>
            <param name="type">类型</param>
            <returns>对象</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject``1">
            <summary>主要入口方法。从数据流中读取指定类型的对象</summary>
            <returns>对象</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type,System.Object@)">
            <summary>主要入口方法。尝试读取目标对象指定成员的值，通过委托方法递归处理成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadRefObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取引用对象</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObjRef``1(NewLife.Reflection.Func{``0})">
            <summary>读取引用对象的包装，能自动从引用对象集合里面读取，如果不存在，则调用委托读取对象，并加入引用对象集合</summary>
            <typeparam name="T"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObjRef(System.Type,System.Object@,System.Int32@)">
            <summary>读取对象引用。</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="index">引用计数</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadObjRefIndex">
            <summary>读取对象引用计数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.AddObjRef(System.Int32,System.Object)">
            <summary>添加对象引用</summary>
            <param name="index">引用计数</param>
            <param name="value">对象</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadCustomObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取自定义对象</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>读取成员之前获取要读取的成员，默认是index处的成员。</summary>
            <remarks>实现者可以重载，改变当前要读取的成员，如果当前成员不在数组里面，则实现者自己跳到下一个可读成员</remarks>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="members">可匹配成员数组</param>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GetMemberByName(NewLife.Serialization.IObjectMemberInfo[],System.String)">
            <summary>根据名称，从成员数组中查找成员</summary>
            <param name="members">可匹配成员数组</param>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取对象成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取对象成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadLengths">
            <summary>读取多维数组相关参数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ArrEnum(System.Array,System.Action{System.Int32[]},System.Object)">
            <summary>给多维数组赋值</summary>
            <param name="arr"></param>
            <param name="func"></param>
            <param name="value"></param>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnObjectReading">
            <summary>读对象前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnObjectReaded">
            <summary>读对象后触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnMemberReading">
            <summary>读成员前触发。</summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnMemberReaded">
            <summary>读成员后触发。</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderBase`1.EndOfStream">
            <summary>获取一个值，该值表示当前的流位置是否在流的末尾。</summary>
            <returns>如果当前的流位置在流的末尾，则为 true；否则为 false。</returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadByte">
            <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，并使当前位置提升 count 个字节。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.FromHex(System.String)">
            <summary>解密</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadSingle">
            <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadDouble">
            <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadString">
            <summary>从当前流中读取一个字符串。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadBoolean">
            <summary>从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadDecimal">
            <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadGuid">
            <summary>读取Guid</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.OnReadIPAddress">
            <summary>读取IPAddress</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.OnReadIPEndPoint">
            <summary>读取IPEndPoint</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadValue(System.Type,System.Object@)">
            <summary>尝试读取值类型数据，返回是否读取成功</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.TextReaderBase`1.UseSize">
            <summary>是否使用大小，如果使用，将在写入数组、集合和字符串前预先写入大小。字符串类型读写器一般带有边界，不需要使用大小</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.#ctor">
            <summary>构造方法</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadBytes(System.Int32)">
            <summary>读取字节数组</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadBoolean">
            <summary>从当前流位置读取一个布尔型数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDateTime">
            <summary>从当前流位置读取一个日期时间型数据,支持的格式参考ParseDateTimeString的说明</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.TryParseDateTimeString(System.String,System.DateTime@)">
            <summary>解析日期时间字符串,可以处理多种日期时间格式,包括JsDateTimeFormats枚举中的格式,以及js中toGMTString()的格式</summary>
            <param name="str"></param>
            <param name="ret"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.NUMBER_TYPES">
            <summary>数字类型 包括整型和浮点型</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.INTEGER_TYPES">
            <summary>整型类型</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNumber``1(System.String,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>从当前流位置读取一个指定T类型的数字,T应该是int long float double及相关类型</summary>
            <typeparam name="T"></typeparam>
            <param name="exceptMsg">断言读取时断言失败的附加异常信息</param>
            <param name="expected">期望的节点类型,和T参数有关,一般浮点数额外有AtomElementType.FLOAT</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNumber``1(System.String,System.Globalization.NumberStyles,System.IConvertible@)">
            <summary>从指定字符串中尝试读取指定T类型的数字,T应该是int long float double及相关类型</summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <param name="numStyles"></param>
            <param name="result">返回值,可以直接强类型转换或者使用ToXXX转换</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.GetExponentOrNotStyle(System.String,NewLife.Serialization.JsonReader.AtomElementType[],NewLife.Serialization.JsonReader.AtomElementType)">
            <summary>从给定的实际原子节点类型中返回对应的数字格式</summary>
            <param name="str"></param>
            <param name="expected"></param>
            <param name="actual">实际原子节点类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadInt16">
            <summary>从当前流位置读取一个16位长度的整型数字</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadInt32">
            <summary>从当前流位置读取一个32位长度的整型数字</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadInt64">
            <summary>从当前流位置读取一个64位长度的整型数字</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadSingle">
            <summary>从当前流位置读取一个单精度浮点数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDouble">
            <summary>从当前流位置读取一个双精度浮点数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDecimal">
            <summary>从当前流位置读取一个十进制数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadString">
            <summary>从当前流位置读取一个字符串</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadChar">
            <summary>从当前流位置读取一个字符,如果读到的是字符串,将取第一个字符;如果读到的是数字,将作为Unicode字符处理;或者读到null</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadChars(System.Int32)">
            <summary>从当前流位置读取字符数组</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadGuid">
            <summary>读取Guid</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadIPAddress">
            <summary>读取IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadIPEndPoint">
            <summary>读取IP端口地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadEnumerable``1(``0[]@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取一个枚举类型</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取枚举项目</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取实现了序列化接口的类型</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取一个字典类型</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取一个字典项</summary>
            <param name="keyType"></param>
            <param name="valueType"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.AssertReadNextAtomElement(System.String,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            断言读取下一个原子元素,返回实际读到的原子元素类型,一般用于断言{}[]:,
            
            要得到具体读取到的值应使用另外一个重载
            </summary>
            <param name="msg">断言失败时的附加异常信息</param>
            <param name="expected">期望的原子元素类型</param>
            <exception cref="T:NewLife.Serialization.JsonReader.JsonReaderAssertException">如果断言失败</exception>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.AssertReadNextAtomElement(System.String,System.String@,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            断言读取下一个原子元素,返回实际读到的原子元素类型
            
            </summary>
            <param name="msg">断言失败时的附加异常信息</param>
            <param name="str">实际读到的内容,字面值是直接的字符串,字符串类型也是实际的字符串(不包括字符串头尾的双引号)</param>
            <param name="expected">期望的原子元素类型</param>
            <exception cref="T:NewLife.Serialization.JsonReader.JsonReaderAssertException">如果断言失败</exception>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.AssertReadNextAtomElement(System.Boolean,System.String,System.String@,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            断言读取下一个原子元素,返回实际读到的原子元素类型
            
            可以选择是否仅仅Peek而不移动流位置
            </summary>
            <param name="onlyPeek">是否仅Peek而不移动流位置(不移动到有效值的位置),这将会使str不会返回字符串内容(仅一个双引号)</param>
            <param name="msg"></param>
            <param name="str"></param>
            <param name="expected"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextAtomElement(System.String@)">
            <summary>读取下一个原子元素,非{} []这类复合元素</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextAtomElement(System.Boolean,System.String@)">
            <summary>读取下一个原子元素,非{} []这类复合元素</summary>
            <param name="str"></param>
            <param name="onlyPeek">是否仅Peek而不移动流位置(不移动到有效值的位置),这将会使str不会返回字符串内容(仅一个双引号)</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.MoveNextStreamPostition">
            <summary>将当前输入流位置向后移动一个字符,并返回读取到的字符</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextString(System.String@)">
            <summary>读取下一个字符串,当前reader流已经在"之后,读取到的字符串应该是不包含结尾的双引号</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextEscapeChar">
            <summary>读取下一个转义字符,流已处于转义符\后</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextLiteral(System.Boolean,System.String@)">
            <summary>读取下一个字面值,可能是true false null 数字 无法识别,调用时第一个字符一定是一个字面值</summary>
            <param name="onlyPeek">是否仅Peek而不移动流位置(不移动到有效值的位置),这将会使str不会返回字符串内容(仅一个双引号)</param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.SkipNext">
            <summary>跳过下一个值,可以是跳过对象声明(以及对象成员名称 成员值声明),数组声明,以及基础类型</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.SkipNext(System.Int32)">
            <summary>跳过下面的值,并指定初始复合对象深度,通过提供大于0的初始深度可以跳过一直到 偏移指定深度 的复合对象位置,一般是读取到]或者}符号之后</summary>
            <param name="initDepth">初始化复合对象深度,应该是大于等于0的数字,小于0时将不做任何操作</param>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.ComplexObjectDepth">
            <summary>复合对象深度,包括自定义对象和字典,主要用于平衡[]{},用于成员数量不一致时</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AUTODETECT_TYPES">
            <summary>自动探测类型时断言的原子元素类型</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.MEMBERNAME_EXPECTED_TYPES">
            <summary>尝试读取成员时期望的原子元素类型</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取一个对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadCustomObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取一个自定义对象,即{}包括的数据</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ComplexObjectDepthIsOverflow">
            <summary>当前解析复合对象深度是否超出,用于避免循环引用可能引起的堆栈溢出,仅在Settings.RepeatedActionType是RepeatedAction.DepthLimit时才可能返回true</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>读取当前成员名称</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="members"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>从当前流位置读取成员值</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="member"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadLengths">
            <summary>读取多维数组的维度</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.Stream">
            <summary>数据流。更改数据流后，重置Reader为空，以使用新的数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.EndOfStream">
            <summary>获取一个值，该值表示当前的流位置是否在流的末尾。</summary>
            <returns>如果当前的流位置在流的末尾，则为 true；否则为 false。</returns>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.ReservedTypeClass">
            <summary>表示类型是无法实例化的类型,用于避免父类CheckAndReadType中的ReadType被执行,因为json的类型标识是另外的格式</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.AtomElementType">
            <summary>原子元素类型</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NONE">
            <summary>无 一般表示结尾</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACE_OPEN">
            <summary>大括号开始 {</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACE_CLOSE">
            <summary>大括号结束 }</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACKET_OPEN">
            <summary>方括号开始 [</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACKET_CLOSE">
            <summary>方括号结束 ]</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.COLON">
            <summary>冒号 :</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.COMMA">
            <summary>逗号 ,</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.STRING">
            <summary>字符串 "包含的</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.LITERAL">
            <summary>字面值 无法识别的字面值</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.TRUE">
            <summary>字面值 true</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.FALSE">
            <summary>字面值 false</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NULL">
            <summary>字面值 null</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NUMBER">
            <summary>字面值 数字,非科学计数法表示的</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NUMBER_EXP">
            <summary>字面值 数字,科学计数发表示的</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.FLOAT">
            <summary>字面值 浮点数,非科学计数法表示的浮点数</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.FLOAT_EXP">
            <summary>字面值 浮点数,科学计数法表示的浮点数</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.JsonReaderAssertException">
            <summary>json reader断言异常,属于解析异常的一部分,主要是提供的数据不符合约定</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReaderParseException">
            <summary>json reader解析异常,主要是信息格式不正确</summary>
        </member>
        <member name="T:NewLife.Exceptions.XException">
            <summary>X组件异常</summary>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="innerException"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>初始化</summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonReaderParseException.#ctor(System.Int64,System.Int64,System.String)">
            <summary>构造一个解析异常</summary>
            <param name="line">行</param>
            <param name="column">列</param>
            <param name="message">额外的异常信息</param>
        </member>
        <member name="P:NewLife.Serialization.JsonReaderParseException.Line">
            <summary>解析异常的行</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReaderParseException.Column">
            <summary>解析异常的列</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReaderParseException.Message">
            <summary>解析异常的详细信息</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.JsonReaderAssertException.#ctor(System.Int64,System.Int64,NewLife.Serialization.JsonReader.AtomElementType[],NewLife.Serialization.JsonReader.AtomElementType,System.String)">
            <summary>构造一个断言异常</summary>
            <param name="line"></param>
            <param name="column"></param>
            <param name="expected">期望的节点类型</param>
            <param name="actual">实际节点类型</param>
            <param name="messageInfo">额外的描述信息</param>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.JsonReaderAssertException.FormatMessage(System.Int64,System.Int64,NewLife.Serialization.JsonReader.AtomElementType[],NewLife.Serialization.JsonReader.AtomElementType,System.String)">
            <summary>获取相似参数下JsonReaderAssertException类的异常信息,在不需要JsonReaderAssertException异常,但需要异常信息时使用</summary>
            <param name="line"></param>
            <param name="column"></param>
            <param name="expected"></param>
            <param name="actual"></param>
            <param name="messageInfo"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.MessageInfo">
            <summary>断言异常的额外异常信息</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.Expected">
            <summary>断言期望的元素类型</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.Actual">
            <summary>断言实际得到的类型,如果期望类型中包含这个类型,即表示错误是非元素基础类型错误,而是由于元素格式不符合理想,比如期望是日期时间格式的字符串</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.Message">
            <summary>异常信息,包含额外信息</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryReaderX">
            <summary>二进制读取器</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接读取，自定义类型反射得到成员，逐层递归读取！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            
            二进制序列化，并不仅仅是为了序列化一个对象那么简单，它最初的目标是实现一个高度可自定义的序列化组件，后来提升为以序列化各种协议为重点。
            理论上，只要用实体类实现了各种协议（文件格式），那么它就能只用一个Read/Write实现协议实体对象与二进制数据流之间的映射。
            </remarks>
            <example>
            标准用法：
            <code>
            var reader = new BinaryReaderX();
            reader.Stream = stream;
            entity = reader.ReadObject&lt;TEntity&gt;();
            // 使用数据流填充已有对象，这是几乎所有其它序列化框架所不具有的功能
            // reader.ReadObject(null, ref entity);
            </code>
            </example>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.#ctor">
            <summary>实例化一个二进制读取器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.#ctor(System.IO.Stream)">
            <summary>实例化一个二进制读取器</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，并使当前位置提升 count 个字节。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadIntBytes(System.Int32)">
            <summary>判断字节顺序</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.OnReadType">
            <summary>读取Type</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadRefObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取引用对象</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadObjRef(System.Type,System.Object@,System.Int32@)">
            <summary>读取对象引用。</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="index">引用计数</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>读取成员之前获取要读取的成员，默认是index处的成员，实现者可以重载，改变当前要读取的成员，如果当前成员不在数组里面，则实现者自己跳到下一个可读成员。</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="members">可匹配成员数组</param>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.OnReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Expect(System.Byte[])">
            <summary>探测下一个可用的字节是否预期字节，并且不提升字节的位置。</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Expect(System.Int16[])">
            <summary>探测下一个可用的数字是否预期数字，并且不提升字节的位置。</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Expect(System.UInt16[])">
            <summary>探测下一个可用的数字是否预期数字，并且不提升字节的位置。</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Expect(System.Int32[])">
            <summary>探测下一个可用的数字是否预期数字，并且不提升字节的位置。</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Expect(System.UInt32[])">
            <summary>探测下一个可用的数字是否预期数字，并且不提升字节的位置。</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Expect``1(NewLife.Reflection.Func{``0},``0[])">
            <summary>探测下一个可用的数值是否预期数值，并且不提升字节的位置。</summary>
            <param name="func">读取数值的方法，比如ReadInt32等</param>
            <param name="values">预期数值列表</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.EnableTraceStream">
            <summary>使用跟踪流</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadLine">
            <summary>从数据流中读取一行，直到遇到换行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadToEnd">
            <summary>从数据流中读取一行，直到最后</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.BinaryReaderX.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryReaderX.Stream">
            <summary>数据流。更改数据流后，重置Reader为空，以使用新的数据流</summary>
        </member>
        <member name="T:NewLife.Reflection.MethodBodyReader">
            <summary>方法体读取器</summary>
        </member>
        <member name="M:NewLife.Reflection.MethodBodyReader.#ctor(System.Reflection.MethodInfo)">
            <summary>为方法信息创建方法体读取器</summary>
            <param name="method"></param>
        </member>
        <member name="M:NewLife.Reflection.MethodBodyReader.ConstructInstructions(System.Reflection.MethodInfo)">
            <summary>通过IL字节码构建指令集合</summary>
            <param name="mi"></param>
        </member>
        <member name="M:NewLife.Reflection.MethodBodyReader.GetBodyCode">
            <summary>获取方法体IL代码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodBodyReader.GetCode">
            <summary>获取方法IL代码，包括签名</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodBodyReader.LoadOpCodes">
            <summary>加载操作码</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodBodyReader.Method">
            <summary>方法</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodBodyReader.Instructions">
            <summary>指令集合</summary>
        </member>
        <member name="T:NewLife.Compression.CompressionMethod">
            <summary>压缩方法</summary>
        </member>
        <member name="F:NewLife.Compression.CompressionMethod.Stored">
            <summary>A direct copy of the file contents is held in the archive</summary>
        </member>
        <member name="F:NewLife.Compression.CompressionMethod.Deflated">
            <summary>
            Common Zip compression method using a sliding dictionary
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
        </member>
        <member name="F:NewLife.Compression.CompressionMethod.Deflate64">
            <summary>An extension to deflate with a 64KB window. Not supported by #Zip currently</summary>
        </member>
        <member name="F:NewLife.Compression.CompressionMethod.BZip2">
            <summary>BZip2 compression. Not supported by #Zip.</summary>
        </member>
        <member name="F:NewLife.Compression.CompressionMethod.WinZipAES">
            <summary>WinZip special for AES encryption, Now supported by #Zip.</summary>
        </member>
        <member name="T:NewLife.Compression.HostSystem">
            <summary>系统类型</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Msdos">
            <summary>Host system = MSDOS</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Amiga">
            <summary>Host system = Amiga</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.OpenVms">
            <summary>Host system = Open VMS</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Unix">
            <summary>Host system = Unix</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.VMCms">
            <summary>Host system = VMCms</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.AtariST">
            <summary>Host system = Atari ST</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.OS2">
            <summary>Host system = OS2</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Macintosh">
            <summary>Host system = Macintosh</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.ZSystem">
            <summary>Host system = ZSystem</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Cpm">
            <summary>Host system = Cpm</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.WindowsNT">
            <summary>Host system = Windows NT</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.MVS">
            <summary>Host system = MVS</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Vse">
            <summary>Host system = VSE</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.AcornRisc">
            <summary>Host system = Acorn RISC</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Vfat">
            <summary>Host system = VFAT</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.AlternateMvs">
            <summary>Host system = Alternate MVS</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.BeOS">
            <summary>Host system = BEOS</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.Tandem">
            <summary>Host system = Tandem</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.OS400">
            <summary>Host system = OS400</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.OSX">
            <summary>Host system = OSX</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.WinRar">
            <summary>WinRar</summary>
        </member>
        <member name="F:NewLife.Compression.HostSystem.WinZipAES">
            <summary>Host system = WinZIP AES</summary>
        </member>
        <member name="T:NewLife.Compression.GeneralBitFlags">
            <summary>通用标识位</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Encrypted">
            <summary>Bit 0 if set indicates that the file is encrypted</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Method">
            <summary>Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Descriptor">
            <summary>Bit 3 if set indicates a trailing data desciptor is appended to the entry data</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.ReservedPKware4">
            <summary>Bit 4 is reserved for use with method 8 for enhanced deflation</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.StrongEncryption">
            <summary>Bit 6 if set indicates strong encryption has been used for this entry.</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Unused7">
            <summary>Bit 7 is currently unused</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Unused8">
            <summary>Bit 8 is currently unused</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Unused9">
            <summary>Bit 9 is currently unused</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.Unused10">
            <summary>Bit 10 is currently unused</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.EnhancedCompress">
            <summary>Bit 12 is documented as being reserved by PKware for enhanced compression.</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.ReservedPkware14">
            <summary>Bit 14 is documented as being reserved for use by PKware</summary>
        </member>
        <member name="F:NewLife.Compression.GeneralBitFlags.ReservedPkware15">
            <summary>Bit 15 is documented as being reserved for use by PKware</summary>
        </member>
        <member name="T:NewLife.Web.WebDownload">
            <summary>提供网页下载支持，在服务端把一个数据流作为附件传给浏览器，带有断点续传和限速的功能</summary>
        </member>
        <member name="M:NewLife.Web.WebDownload.ParseMode(System.String)">
            <summary>分析模式</summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebDownload.Render">
            <summary>输出数据流</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.FileName">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.Mode">
            <summary>附件配置模式，是在浏览器直接打开，还是提示另存为</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.Speed">
            <summary>速度，0表示不限制</summary>
        </member>
        <member name="T:NewLife.Web.WebDownload.DispositionMode">
            <summary>附件配置模式</summary>
        </member>
        <member name="F:NewLife.Web.WebDownload.DispositionMode.Inline">
            <summary>内联模式，在浏览器直接打开</summary>
        </member>
        <member name="F:NewLife.Web.WebDownload.DispositionMode.Attachment">
            <summary>附件模式，提示另存为</summary>
        </member>
        <member name="T:NewLife.Reflection.DynamicAssembly">
            <summary>全局方法程序集</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicAssembly.AddGlobalMethod(System.Reflection.MethodInfo,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>添加全局方法</summary>
            <param name="method"></param>
            <param name="fun"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicAssembly.Save(System.String)">
            <summary>保存</summary>
            <param name="fileName"></param>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.AsmBuilder">
            <summary>程序集创建器</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.ModBuilder">
            <summary>模块创建器</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.TypeBuilder">
            <summary>类型创建器</summary>
        </member>
        <member name="T:NewLife.Serialization.ObjectInfo">
            <summary>对象信息</summary>
        </member>
        <member name="F:NewLife.Serialization.ObjectInfo.DefaultStreamingContext">
            <summary>默认上下文</summary>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.CreateObjectMemberInfo(System.Reflection.MemberInfo)">
            <summary>创建反射成员信息</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.CreateObjectMemberInfo(System.String,System.Type,System.Object)">
            <summary>创建简单成员信息</summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.GetMembers(System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>
            获取指定对象的可序列化成员信息。优先考虑ISerializable接口。
            对于Write，该方法没有任何问题；对于Read，如果是ISerializable接口，并且value是空，则可能无法取得成员信息。
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="isField">是否字段</param>
            <param name="isBaseFirst">是否基类成员排在前面</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.FindFields(System.Type,System.Boolean)">
            <summary>取得所有字段</summary>
            <param name="type"></param>
            <param name="isBaseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.FindProperties(System.Type,System.Boolean)">
            <summary>取得所有属性</summary>
            <param name="type"></param>
            <param name="isBaseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.GetDefaultObject(System.Type)">
            <summary>获取某个类型的默认对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ObjectContainer">
            <summary>实现 <seealso cref="T:NewLife.Model.IObjectContainer"/> 接口的对象容器</summary>
            <remarks>
            1，如果容器里面没有这个类型，则返回空；
            2，如果容器里面包含这个类型，<see cref="M:NewLife.Model.ObjectContainer.ResolveInstance(System.Type,System.Object,System.Boolean)"/>返回单例；
            3，如果容器里面包含这个类型，<see cref="M:NewLife.Model.ObjectContainer.Resolve(System.Type,System.Object,System.Boolean)"/>创建对象返回多实例；
            4，如果有带参数构造函数，则从容器内获取各个参数的实例，最后创建对象返回。
            
            这里有一点跟大多数对象容器非常不同，其它对象容器会控制对象的生命周期，在对象不再使用时收回到容器里面。
            这里的对象容器主要是为了用于解耦，所以只有最简单的功能实现。
            
            代码注册的默认优先级是0；
            配置注册的默认优先级是1；
            自动注册的外部实现（非排除项）的默认优先级是1，排除项的优先级是0；
            所以，配置注册的优先级最高
            </remarks>
        </member>
        <member name="T:NewLife.Model.IObjectContainer">
            <summary>对象容器接口</summary>
            <remarks>
            1，如果容器里面没有这个类型，则返回空；
            2，如果容器里面包含这个类型，<see cref="M:NewLife.Model.IObjectContainer.ResolveInstance(System.Type,System.Object,System.Boolean)"/>返回单例；
            3，如果容器里面包含这个类型，<see cref="M:NewLife.Model.IObjectContainer.Resolve(System.Type,System.Object,System.Boolean)"/>创建对象返回多实例；
            4，如果有带参数构造函数，则从容器内获取各个参数的实例，最后创建对象返回。
            
            这里有一点跟大多数对象容器非常不同，其它对象容器会控制对象的生命周期，在对象不再使用时收回到容器里面。
            这里的对象容器主要是为了用于解耦，所以只有最简单的功能实现。
            
            代码注册的默认优先级是0；
            配置注册的默认优先级是1；
            自动注册的外部实现（非排除项）的默认优先级是1，排除项的优先级是0；
            所以，配置注册的优先级最高
            </remarks>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Register(System.Type,System.Type,System.Object,System.Object,System.Int32)">
            <summary>注册类型和名称</summary>
            <param name="from">接口类型</param>
            <param name="to">实现类型</param>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Register``2(System.Object,System.Int32)">
            <summary>注册类型和名称</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">实现类型</typeparam>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Register``1(System.Object,System.Object,System.Int32)">
            <summary>注册类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.AutoRegister(System.Type,System.Type[])">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <param name="from">接口或基类</param>
            <param name="excludeTypes">要排除的类型，一般是内部默认实现</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.AutoRegister(System.Type,NewLife.Reflection.Func{System.Object,System.Object},System.Object,System.Int32,System.Type[])">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <param name="from">接口或基类</param>
            <param name="getidCallback">用于从外部类型对象中获取标识的委托</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <param name="excludeTypes">要排除的类型，一般是内部默认实现</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.AutoRegister``2">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">要排除的类型，一般是内部默认实现</typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.AutoRegister``2(NewLife.Reflection.Func{System.Object,System.Object},System.Object,System.Int32)">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">要排除的类型，一般是内部默认实现</typeparam>
            <param name="getidCallback">用于从外部类型对象中获取标识的委托</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Resolve(System.Type,System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Resolve``1(System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveInstance(System.Type,System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveInstance``1(System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveAll(System.Type)">
            <summary>解析类型所有已注册的实例</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveAll``1">
            <summary>解析类型所有已注册的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveType(System.Type,System.Object,System.Boolean)">
            <summary>解析接口指定名称的实现类型</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveType``1(System.Object,System.Boolean)">
            <summary>解析接口指定名称的实现类型</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveAllTypes(System.Type)">
            <summary>解析接口所有已注册的实现类型</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveAllMaps(System.Type)">
            <summary>解析接口所有已注册的对象映射</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Model.IObjectContainer.OnRegistering">
            <summary>注册前事件</summary>
        </member>
        <member name="E:NewLife.Model.IObjectContainer.OnRegistered">
            <summary>注册后事件</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.#ctor">
            <summary>初始化一个对象容器实例，自动从配置文件中加载注册</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Register(System.Type,System.Type,System.Object,System.Object,System.Int32)">
            <summary>注册</summary>
            <param name="from">接口类型</param>
            <param name="to">实现类型</param>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Register``2(System.Object,System.Int32)">
            <summary>注册类型和名称</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">实现类型</typeparam>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Register``1(System.Object,System.Object,System.Int32)">
            <summary>注册类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.AutoRegister(System.Type,System.Type[])">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <param name="from">接口或基类</param>
            <param name="excludeTypes">要排除的类型，一般是内部默认实现</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.AutoRegister(System.Type,NewLife.Reflection.Func{System.Object,System.Object},System.Object,System.Int32,System.Type[])">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <param name="from">接口或基类</param>
            <param name="getidCallback">用于从外部类型对象中获取标识的委托</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <param name="excludeTypes">要排除的类型，一般是内部默认实现</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.AutoRegister``2">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">要排除的类型，一般是内部默认实现</typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.AutoRegister``2(NewLife.Reflection.Func{System.Object,System.Object},System.Object,System.Int32)">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">要排除的类型，一般是内部默认实现</typeparam>
            <param name="getidCallback">用于从外部类型对象中获取标识的委托</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Resolve(System.Type,System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Resolve``1(System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveInstance(System.Type,System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，id为null而找不到时，采用第一个注册项；id不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveInstance``1(System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveAll(System.Type)">
            <summary>解析类型所有已注册的实例</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveAll``1">
            <summary>解析类型所有已注册的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveType(System.Type,System.Object,System.Boolean)">
            <summary>解析接口指定名称的实现类型</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveType``1(System.Object,System.Boolean)">
            <summary>解析接口指定名称的实现类型</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveAllTypes(System.Type)">
            <summary>解析类型所有已注册的实例</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveAllMaps(System.Type)">
            <summary>解析接口所有已注册的对象映射</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.LoadConfig">
            <summary>加载配置</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Current">
            <summary>当前容器</summary>
        </member>
        <member name="E:NewLife.Model.ObjectContainer.OnRegistering">
            <summary>注册前事件</summary>
        </member>
        <member name="E:NewLife.Model.ObjectContainer.OnRegistered">
            <summary>注册后事件</summary>
        </member>
        <member name="T:NewLife.Model.IObjectMap">
            <summary>对象映射接口</summary>
        </member>
        <member name="P:NewLife.Model.IObjectMap.Identity">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IObjectMap.ImplementType">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.IObjectMap.Instance">
            <summary>对象实例</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Identity">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.TypeName">
            <summary>类型名</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.ImplementType">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Priority">
            <summary>优先级</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Instance">
            <summary>实例</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Mode">
            <summary>模式</summary>
        </member>
        <member name="T:NewLife.Model.ObjectContainer.ModeFlags">
            <summary>模式标记</summary>
        </member>
        <member name="F:NewLife.Model.ObjectContainer.ModeFlags.Extend">
            <summary>是否扩展，扩展注册将附加在该接口的第一个注册项之后</summary>
        </member>
        <member name="T:NewLife.Compression.ZipFile">
            <summary>Zip文件</summary>
            <remarks>
            Zip定义位于 <a target="_blank" href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">http://www.pkware.com/documents/casestudies/APPNOTE.TXT</a>
            
            本程序只支持Zip基本功能，不支持加密和Zip64（用于超过2G的文件压缩）。
            
            基本常识：GZip/Deflate仅仅是数据压缩算法，只负责压缩一组数据；而Zip仅仅是一种打包用的文件格式，指示多个被压缩后的文件如何组合在一起形成一个压缩包，当然，这些被压缩的文件除了Deflate算法还可能有其它算法。
            
            核心原理：通过二进制序列化框架，实现Zip格式的解析，数据的压缩和解压缩由系统的DeflateStream完成！
            
            关于压缩算法：系统的DeflateStream实现了Deflate压缩算法，但是硬编码了四级压缩（共十级，第四级在快速压缩中压缩率最高）。相关硬编码位于内嵌的FastEncoderWindow类中。
            
            感谢@小董（1287263703）、@Johnses（285732917）的热心帮忙，发现了0字节文件压缩和解压缩的BUG！
            </remarks>
            <example>
            标准压缩：
            <code>
            using (ZipFile zf = new ZipFile())
            {
                zf.AddDirectory("TestZip");
            
                using (var fs = File.Create("ab.zip"))
                {
                    zf.Write(fs);
                }
            }
            </code>
            
            标准解压缩：
            <code>
            using (ZipFile zf = new ZipFile(file))
            {
                zf.Extract("TestZip");
            }
            </code>
            
            快速压缩：
            <code>
            ZipFile.CompressFile("aa.doc");
            ZipFile.CompressDirectory("TestZip");
            </code>
            
            快速解压缩：
            <code>
            ZipFile.Extract("aa.zip", "Test");
            </code>
            </example>
        </member>
        <member name="T:NewLife.DisposeBase">
            <summary>具有销毁资源处理的抽象基类</summary>
            <example>
            <code>
            /// &lt;summary&gt;子类重载实现资源释放逻辑时必须首先调用基类方法&lt;/summary&gt;
            /// &lt;param name="disposing"&gt;从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            /// 因为该方法只会被调用一次，所以该参数的意义不太大。&lt;/param&gt;
            protected override void OnDispose(bool disposing)
            {
                base.OnDispose(disposing);
            
                if (disposing)
                {
                    // 如果是构造函数进来，不执行这里的代码
                }
            }
            </code>
            </example>
        </member>
        <member name="T:NewLife.IDisposable2">
            <summary>具有是否已释放和释放后事件的接口</summary>
        </member>
        <member name="P:NewLife.IDisposable2.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.IDisposable2.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose(System.Boolean)">
            <summary>释放资源，参数表示是否由Dispose调用。该方法保证OnDispose只被调用一次！</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.DisposeBase.Finalize">
            <summary>析构函数</summary>
            <remarks>
            如果忘记调用Dispose，这里会释放非托管资源
            如果曾经调用过Dispose，因为GC.SuppressFinalize(this)，不会再调用该析构函数
            </remarks>
        </member>
        <member name="P:NewLife.DisposeBase.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.DisposeBase.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="M:NewLife.Compression.ZipFile.#ctor">
            <summary>实例化一个Zip文件对象</summary>
        </member>
        <member name="M:NewLife.Compression.ZipFile.#ctor(System.String)">
            <summary>实例化一个Zip文件对象。延迟到第一次使用<see cref="P:NewLife.Compression.ZipFile.Entries"/>时读取</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.#ctor(System.String,System.Text.Encoding)">
            <summary>实例化一个Zip文件对象。延迟到第一次使用<see cref="P:NewLife.Compression.ZipFile.Entries"/>时读取</summary>
            <param name="fileName"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>实例化一个Zip文件对象。延迟到第一次使用<see cref="P:NewLife.Compression.ZipFile.Entries"/>时读取</summary>
            <param name="stream"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.OnDispose(System.Boolean)">
            <summary>释放资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.EnsureRead">
            <summary>使用文件和数据流时，延迟到第一次使用<see cref="P:NewLife.Compression.ZipFile.Entries"/>时读取</summary>
        </member>
        <member name="M:NewLife.Compression.ZipFile.Read(System.IO.Stream,System.Nullable{System.Boolean})">
            <summary>从数据流中读取Zip格式数据</summary>
            <param name="stream">数据流</param>
            <param name="embedFileData">
            当前读取仅读取文件列表等信息，如果设置内嵌数据，则同时把文件数据读取到内存中；否则，在解压缩时需要再次使用数据流。
            如果外部未指定是否内嵌文件数据，则根据数据流是否小于10M来决定是否内嵌。
            </param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.Write(System.IO.Stream)">
            <summary>把Zip格式数据写入到数据流中</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.Write(System.String)">
            <summary>把Zip格式数据写入到文件中</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.Extract(System.String,System.Boolean)">
            <summary>解压缩</summary>
            <param name="outputPath">目标路径</param>
            <param name="overrideExisting">是否覆盖已有文件</param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.Extract(System.String,System.String,System.Boolean)">
            <summary>快速解压缩</summary>
            <param name="fileName"></param>
            <param name="outputPath"></param>
            <param name="overrideExisting"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.AddFile(System.String,System.String,System.Nullable{System.Boolean})">
            <summary>添加文件。
            必须指定文件路径<paramref name="fileName"/>，如果不指定实体名<paramref name="entryName"/>，则使用文件名，并加到顶级目录。</summary>
            <param name="fileName">文件路径</param>
            <param name="entryName">实体名</param>
            <param name="stored">是否仅存储，不压缩</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Compression.ZipFile.AddDirectory(System.String,System.String,System.Nullable{System.Boolean})">
            <summary>添加目录。</summary>
            <remarks>必须指定目录<paramref name="dirName"/>，如果不指定实体名<paramref name="entryName"/>，则加到顶级目录。</remarks>
            <param name="dirName">目录</param>
            <param name="entryName">实体名</param>
            <param name="stored">是否仅存储，不压缩</param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.CompressFile(System.String,System.String)">
            <summary>快速压缩文件。</summary>
            <param name="fileName"></param>
            <param name="outputName"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.CompressDirectory(System.String,System.String)">
            <summary>快速压缩目录。</summary>
            <param name="dirName"></param>
            <param name="outputName"></param>
        </member>
        <member name="M:NewLife.Compression.ZipFile.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Comment">
            <summary>注释</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Encoding">
            <summary>字符串编码</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.UseDirectory">
            <summary>是否使用目录。不使用目录可以减少一点点文件大小，网络上的压缩包也这么做，但是Rar压缩的使用了目录</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EmbedFileDataMaxSize">
            <summary>内嵌文件数据最大大小。小于该大小的文件将加载到内存中，否则保持文件流连接，直到读写文件。默认10M</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Entries">
            <summary>文件实体集合</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Item(System.Int32)">
            <summary>返回指定索引处的实体</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Item(System.String)">
            <summary>返回指定名称的实体</summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Compression.ZipFile.Count">
            <summary>实体个数</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.Signature">
            <summary>签名。end of central dir signature</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.DiskNumber">
            <summary>卷号。number of this disk</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.DiskNumberWithStart">
            <summary>number of the disk with the start of the central directory</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.NumberOfEntriesOnThisDisk">
            <summary>total number of entries in the central directory on this disk</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.NumberOfEntries">
            <summary>total number of entries in the central directory</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.Size">
            <summary>size of the central directory</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.Offset">
            <summary>offset of start of central directory with respect to the starting disk number</summary>
        </member>
        <member name="P:NewLife.Compression.ZipFile.EndOfCentralDirectory.Comment">
            <summary>注释</summary>
        </member>
        <member name="T:NewLife.Collections.WeakRefDictionary`2">
            <summary>弱引用字典，比较适合用作于缓存。</summary>
            <remarks>经过实验表明，弱引用非常容易被回收</remarks>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:NewLife.Xml.XmlConfigFileAttribute">
            <summary>Xml配置文件特性</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String)">
            <summary>指定配置文件名</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String,System.Int32)">
            <summary>指定配置文件名和重新加载时间（毫秒）</summary>
            <param name="fileName"></param>
            <param name="reloadTime"></param>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.FileName">
            <summary>配置文件名</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="T:NewLife.Web.RunTimeModule">
            <summary>页面执行时间模块</summary>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.OnInit">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.WriteRunTime(System.Object,System.EventArgs)">
            <summary>输出运行时间</summary>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.Render">
            <summary>输出</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.Context">
            <summary>上下文</summary>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.IsWriteRunTime">
            <summary>当前请求是否输出执行时间</summary>
            <remarks>如果要所有请求不输出执行时间，则从配置中移除当前模块</remarks>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.HasWrite">
            <summary>当前请求是否已经输出执行时间</summary>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.RunTimeFormat">
            <summary>执行时间字符串</summary>
        </member>
        <member name="T:NewLife.Reflection.MethodInfoX">
            <summary>快速调用。基于DynamicMethod和Emit实现。</summary>
        </member>
        <member name="T:NewLife.Reflection.MemberInfoX">
            <summary>快速访问成员</summary>
        </member>
        <member name="F:NewLife.Reflection.MemberInfoX.DefaultBinding">
            <summary>默认查找标志</summary>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.#ctor(System.Reflection.MemberInfo)">
            <summary>初始化快速访问成员</summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.Create(System.Reflection.MemberInfo)">
            <summary>创建快速访问成员</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.Create(System.Type,System.String)">
            <summary>通过指定类型和成员名称，创建快速访问成员。按照属性、字段、构造、方法、事件的顺序</summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.Invoke(System.Object,System.Object[])">
            <summary>执行方法</summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.GetValue(System.Object)">
            <summary>取值</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.SetValue(System.Object,System.Object)">
            <summary>赋值</summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.GetValue">
            <summary>静态 取值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.SetValue(System.Object)">
            <summary>静态 赋值</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.CreateInstance(System.Object[])">
            <summary>创建实例</summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.op_Implicit(NewLife.Reflection.MemberInfoX)~System.Reflection.MemberInfo">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.op_Implicit(System.Reflection.MemberInfo)~NewLife.Reflection.MemberInfoX">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.HasRefParam(System.Reflection.MethodBase)">
            <summary>是否有引用参数</summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.GetCustomAttributeValue``2">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Type">
            <summary>成员类型</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.TargetType">
            <summary>目标类型</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.IsType">
            <summary>是否类型</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.DocName">
            <summary>文档名</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Item(System.Object)">
            <summary>属性/字段 索引器</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Value">
            <summary>静态 属性/字段 值</summary>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Reflection.MethodBase)">
            <summary>创建</summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Type,System.String)">
            <summary>创建</summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Type,System.String,System.Type[])">
            <summary>创建</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramTypes">参数类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke(System.Object,System.Object[])">
            <summary>参数调用</summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.InvokeByDictionaryParameter(System.Object,System.Collections.IDictionary)">
            <summary>通过字典参数调用</summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke``1(System.Object,System.String,System.Object[])">
            <summary>快速调用方法成员</summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke``2(System.String,System.Object[])">
            <summary>快速调用静态方法</summary>
            <typeparam name="TTarget">目标类型</typeparam>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.InvokeByDictionaryParameter``1(System.Object,System.String,System.Collections.IDictionary)">
            <summary>通过传入参数字典快速调用方法</summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.InvokeByDictionaryParameter``2(System.String,System.Collections.IDictionary)">
            <summary>通过传入参数字典快速调用静态方法</summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.op_Implicit(NewLife.Reflection.MethodInfoX)~System.Reflection.MethodInfo">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.op_Implicit(System.Reflection.MethodInfo)~NewLife.Reflection.MethodInfoX">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Method">
            <summary>目标方法</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Parameters">
            <summary>参数数组</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Handler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Name">
            <summary>类型名称。主要处理泛型</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.FullName">
            <summary>完整类型名称。包含命名空间，但是不包含程序集信息</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.TinyName">
            <summary>不带定义类型的精简类型名称。主要处理泛型</summary>
        </member>
        <member name="T:NewLife.Reflection.MethodInfoX.FastInvokeHandler">
            <summary>快速调用委托</summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.WriterEventArgs">
            <summary>写入器时间参数</summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterEventArgs">
            <summary>读写器事件参数</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterEventArgs.Success">
            <summary>是否成功。</summary>
        </member>
        <member name="M:NewLife.Serialization.WriterEventArgs.#ctor(NewLife.Serialization.WriteObjectCallback)">
            <summary>实例化</summary>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriterEventArgs.Callback">
            <summary>处理成员的委托</summary>
        </member>
        <member name="T:NewLife.Reflection.ConstructorInfoX">
            <summary>快速调用构造函数。基于DynamicMethod和Emit实现。</summary>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.Create(System.Reflection.ConstructorInfo)">
            <summary>创建</summary>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.Create(System.Type,System.Type[])">
            <summary>创建</summary>
            <param name="type"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.Create(System.Type)">
            <summary>创建</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.CreateInstance(System.Object[])">
            <summary>创建实例</summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.op_Implicit(NewLife.Reflection.ConstructorInfoX)~System.Reflection.ConstructorInfo">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.op_Implicit(System.Reflection.ConstructorInfo)~NewLife.Reflection.ConstructorInfoX">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.ConstructorInfoX.Constructor">
            <summary>目标方法</summary>
        </member>
        <member name="P:NewLife.Reflection.ConstructorInfoX.Handler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="T:NewLife.IO.Json">
            <summary>Json</summary>
        </member>
        <member name="M:NewLife.IO.Json.ConvertToType``1(System.Object)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.ConvertToType(System.Object,System.Type)">
            <summary></summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Deserialize``1(System.String)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Deserialize(System.String,System.Type)">
            <summary></summary>
            <param name="input"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.DeserializeObject(System.String)">
            <summary></summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Serialize(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Serialize(System.Object,System.Text.StringBuilder)">
            <summary></summary>
            <param name="obj"></param>
            <param name="output"></param>
        </member>
        <member name="P:NewLife.IO.Json.MaxJsonLength">
            <summary>最大长度</summary>
        </member>
        <member name="P:NewLife.IO.Json.RecursionLimit">
            <summary>递归限制</summary>
        </member>
        <member name="T:NewLife.Collections.HashSet`1">
            <summary>哈希集合。内部采用泛型字典实现，如若在.Net 4.0环境，可直接使用.Net 4.0的HashSet。</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.#ctor">
            <summary>实例化一个哈希集合</summary>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>指定比较接口实例化一个哈希集合</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.#ctor(System.Collections.IEnumerable)">
            <summary>指定来源数据实例化一个哈希集合</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.#ctor(System.Collections.IEnumerable,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>指定来源数据和比较接口实例化一个哈希集合</summary>
            <param name="data"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.Add(`0)">
            <summary>将指定的键和值添加到集合中。</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.Clear">
            <summary>从集合中移除所有的键和值。</summary>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.Contains(`0)">
            <summary>确定集合是否包含指定的元素。</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.CopyTo(`0[],System.Int32)">
            <summary>从特定的 System.Array 索引开始，将集合的元素复制到一个 System.Array 中。</summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.Remove(`0)">
            <summary>从集合中移除特定对象的第一个匹配项。</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.GetEnumerator">
            <summary>返回一个循环访问集合的枚举数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>返回一个循环访问集合的枚举数。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.HashSet`1.Count">
            <summary>获取集合中包含的元素数。</summary>
        </member>
        <member name="P:NewLife.Collections.HashSet`1.IsReadOnly">
            <summary>获取一个值，该值指示集合是否为只读。</summary>
        </member>
        <member name="T:NewLife.Xml.SerializableDictionary`2">
            <summary>支持Xml序列化的泛型字典类 </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor">
            <summary></summary>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary></summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.ReadXml(System.Xml.XmlReader)">
            <summary>读取Xml</summary>
            <param name="reader">Xml读取器</param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.WriteXml(System.Xml.XmlWriter)">
            <summary>写入Xml</summary>
            <param name="writer">Xml写入器</param>
        </member>
        <member name="T:NewLife.Log.XTrace">
            <summary>日志类，包含跟踪调试功能</summary>
            <remarks>
            该静态类包括写日志、写调用栈和Dump进程内存等调试功能。
            
            默认写日志到文本文件，可通过挂接<see cref="E:NewLife.Log.XTrace.OnWriteLog"/>事件来增加日志输出方式。
            改变日志输出方式后，可通过<see cref="P:NewLife.Log.XTrace.UseFileLog"/>不再向文本文件输出日志。
            对于控制台工程，可以直接通过<see cref="M:NewLife.Log.XTrace.UseConsole(System.Boolean)"/>方法，把日志输出重定向为控制台输出，并且可以为不同线程使用不同颜色。
            </remarks>
        </member>
        <member name="F:NewLife.Log.XTrace.Log">
            <summary>文本文件日志</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.Write(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.Write(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteException(System.Exception)">
            <summary>输出异常日志</summary>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteExceptionWhenDebug(System.Exception)">
            <summary>输出异常日志</summary>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.InitLog">
            <summary>
            2012.11.05 修正初次调用的时候，由于同步BUG，导致Log为空的问题。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.UseConsole(System.Boolean)">
            <summary>使用控制台输出日志，只能调用一次</summary>
            <param name="useColor"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.UseWinForm(System.Boolean)">
            <summary>拦截WinForm异常并记录日志，可指定是否用<see cref="T:System.Windows.Forms.MessageBox"/>显示。</summary>
            <param name="showErrorMessage">发为捕获异常时，是否显示提示，默认显示</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteMiniDump(System.String)">
            <summary>写当前线程的MiniDump</summary>
            <param name="dumpFile">如果不指定，则自动写入日志目录</param>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack">
            <summary>堆栈调试。
            输出堆栈信息，用于调试时处理调用上下文。
            本方法会造成大量日志，请慎用。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack(System.Int32)">
            <summary>堆栈调试。</summary>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack(System.Int32,System.Int32)">
            <summary>堆栈调试</summary>
            <param name="start">开始方法数，0是DebugStack的直接调用者</param>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.GetCaller(System.Int32,System.Int32,System.String)">
            <summary>获取调用栈</summary>
            <param name="start"></param>
            <param name="maxNum"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.XTrace.UseFileLog">
            <summary>使用文件日志</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.LogPath">
            <summary>日志路径</summary>
        </member>
        <member name="E:NewLife.Log.XTrace.OnWriteLog">
            <summary>写日志事件。</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.Debug">
            <summary>是否调试。如果代码指定了值，则只会使用代码指定的值，否则每次都读取配置。</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.TempPath">
            <summary>临时目录</summary>
        </member>
        <member name="T:NewLife.Log.XTrace.MiniDump">
            <summary>
            该类要使用在windows 5.1 以后的版本，如果你的windows很旧，就把Windbg里面的dll拷贝过来，一般都没有问题。
            DbgHelp.dll 是windows自带的 dll文件 。
            </summary>
        </member>
        <member name="T:NewLife.Log.XTrace.MiniDump.MinidumpExceptionInfo">
            <summary>MINIDUMP_EXCEPTION_INFORMATION</summary>
        </member>
        <member name="T:NewLife.Serialization.WriteObjectEventArgs">
            <summary>写入对象事件参数</summary>
        </member>
        <member name="M:NewLife.Serialization.WriteObjectEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>实例化</summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteObjectEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteObjectEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="T:NewLife.Serialization.IAccessor">
            <summary>序列化访问器。接口实现者可以在这里完全自定义行为（返回true），也可以通过设置事件来影响行为（返回false）</summary>
            <example>
            显式实现接口默认代码：
            <code>
            Boolean IAccessor.Read(IReader reader) { return false; }
            
            Boolean IAccessor.ReadComplete(IReader reader, Boolean success) { return success; }
            
            Boolean IAccessor.Write(IWriter writer) { return false; }
            
            Boolean IAccessor.WriteComplete(IWriter writer, Boolean success) { return success; }
            </code>
            </example>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Read(NewLife.Serialization.IReader)">
            <summary>从读取器中读取数据到对象。接口实现者可以在这里完全自定义行为（返回true），也可以通过设置事件来影响行为（返回false）</summary>
            <param name="reader">读取器</param>
            <returns>是否读取成功，若返回成功读取器将不再读取该对象</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.ReadComplete(NewLife.Serialization.IReader,System.Boolean)">
            <summary>从读取器中读取数据到对象后执行。接口实现者可以在这里取消Read阶段设置的事件</summary>
            <param name="reader">读取器</param>
            <param name="success">是否读取成功</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Write(NewLife.Serialization.IWriter)">
            <summary>把对象数据写入到写入器。接口实现者可以在这里完全自定义行为（返回true），也可以通过设置事件来影响行为（返回false）</summary>
            <param name="writer">写入器</param>
            <returns>是否写入成功，若返回成功写入器将不再读写入对象</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.WriteComplete(NewLife.Serialization.IWriter,System.Boolean)">
            <summary>把对象数据写入到写入器后执行。接口实现者可以在这里取消Write阶段设置的事件</summary>
            <param name="writer">写入器</param>
            <param name="success">是否写入成功</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:NewLife.Serialization.FieldSizeAttribute">
            <summary>字段大小特性。</summary>
            <remarks>
            可以通过Size指定字符串或数组的固有大小，为0表示自动计算；也可以通过指定参考字段ReferenceName，然后从其中获取大小。
            支持_Header._Questions形式的多层次引用字段
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.Int32)">
            <summary>通过Size指定字符串或数组的固有大小，为0表示自动计算</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String,System.Int32)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
            <param name="size">在参考字段值基础上的增量，可以是正数负数</param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.FindReference(System.Object,System.Reflection.MemberInfo,System.Object@)">
            <summary>找到所引用的参考字段</summary>
            <param name="target"></param>
            <param name="member"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.SetReferenceSize(System.Object,System.Reflection.MemberInfo,System.Text.Encoding)">
            <summary>设置目标对象的引用大小值</summary>
            <param name="target"></param>
            <param name="member"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.GetReferenceSize(System.Object,System.Reflection.MemberInfo)">
            <summary>获取目标对象的引用大小值</summary>
            <param name="target"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.Size">
            <summary>大小。0表示自动计算大小</summary>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName">
            <summary>参考大小字段名</summary>
        </member>
        <member name="T:NewLife.Messaging.ChannelMessage">
            <summary>通道消息。封装带有通道编号的消息</summary>
        </member>
        <member name="T:NewLife.Messaging.Message">
            <summary>消息实体基类</summary>
            <remarks>
            用消息实体来表达行为和数据，更加直观。
            同时，指定一套序列化和反序列化机制，实现消息实体与传输形式（二进制数据、XML、Json）的互相转换。
            如果消息较为简单，建议重载<see cref="M:NewLife.Messaging.Message.OnWrite(System.IO.Stream,NewLife.Serialization.RWKinds)"/>和<see cref="M:NewLife.Messaging.Message.OnRead(System.IO.Stream,NewLife.Serialization.RWKinds)"/>以得到更好的性能。
            
            消息实体仿照Windows消息来设计，拥有一部分系统内置消息，同时允许用户自定义消息。
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.Message.Init">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Messaging.Message.Write(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>序列化当前消息到流中</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="M:NewLife.Messaging.Message.OnWrite(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>把消息写入流中，默认调用序列化框架</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="M:NewLife.Messaging.Message.GetStream(NewLife.Serialization.RWKinds)">
            <summary>序列化为数据流</summary>
            <param name="rwkind"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Read(System.IO.Stream,NewLife.Serialization.RWKinds,System.Boolean)">
            <summary>从流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="rwkind"></param>
            <param name="ignoreException">忽略异常。如果忽略异常，读取失败时将返回空，并还原数据流位置</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.OnRead(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>从流中读取消息内容，默认调用序列化框架</summary>
            <param name="stream"></param>
            <param name="rwkind"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Read``1(System.IO.Stream)">
            <summary>从流中读取消息</summary>
            <typeparam name="TMessage"></typeparam>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.OnReadWriteSet(NewLife.Serialization.IReaderWriter)">
            <summary>读写前设置。每个消息可根据自己需要进行调整</summary>
            <param name="rw"></param>
        </member>
        <member name="M:NewLife.Messaging.Message.PeekKind(System.IO.Stream)">
            <summary>探测消息类型，不移动流指针</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.PeekType(System.IO.Stream)">
            <summary>探测消息类型，不移动流指针</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.CopyFrom(NewLife.Messaging.Message)">
            <summary>从源消息克隆设置和可序列化成员数据</summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.Message.Kind">
            <summary>消息类型</summary>
            <remarks>第一个字节的第一位决定是否存在消息头。</remarks>
        </member>
        <member name="P:NewLife.Messaging.Message.UserState">
            <summary>在消息处理过程中附带的用户对象。不参与序列化</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Debug">
            <summary>是否调试，输出序列化过程</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.DumpStreamWhenError">
            <summary>出错时Dump数据流到文件中</summary>
        </member>
        <member name="M:NewLife.Messaging.ChannelMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.ChannelMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.ChannelMessage.Channel">
            <summary>消息通道</summary>
        </member>
        <member name="P:NewLife.Messaging.ChannelMessage.SessionID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Messaging.ChannelMessage.Message">
            <summary>内部消息对象</summary>
        </member>
        <member name="T:NewLife.IO.StreamWriterX">
            <summary>增强的数据流写入器</summary>
            <remarks>
            StreamWriter太恶心了，自动把流给关闭了，还没有地方设置。
            </remarks>
        </member>
        <member name="M:NewLife.IO.StreamWriterX.#ctor(System.IO.Stream)">
            <summary>用 UTF-8 编码及默认缓冲区大小，为指定的流初始化 <see cref="T:System.IO.StreamWriter" /> 类的一个新实例。</summary>
            <param name="stream">要写入的流。</param>
            <exception cref="T:System.ArgumentException"><paramref name="stream" /> 不可写。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.IO.StreamWriterX.#ctor(System.String)">
            <summary>使用默认编码和缓冲区大小，为指定路径上的指定文件初始化 <see cref="T:System.IO.StreamWriter" /> 类的新实例。</summary>
            <param name="path">要写入的完整文件路径。<paramref name="path" /> 可以是一个文件名。</param>
            <exception cref="T:System.UnauthorizedAccessException">访问被拒绝。</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path" /> 为空字符串 ("")。- 或 -<paramref name="path" /> 包含系统设备的名称（com1、com2 等等）。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 null。</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，比如在未映射的驱动器上。</exception>
            <exception cref="T:System.IO.PathTooLongException">指定的路径、文件名或者两者都超出了系统定义的最大长度。例如，在基于 Windows 的平台上，路径必须小于 248 个字符，文件名必须小于 260 个字符。</exception>
            <exception cref="T:System.IO.IOException"><paramref name="path" /> 包含不正确或无效的文件名、目录名或卷标的语法。</exception>
            <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        </member>
        <member name="M:NewLife.IO.StreamWriterX.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>用指定的编码及默认缓冲区大小，为指定的流初始化 <see cref="T:System.IO.StreamWriter" /> 类的新实例。</summary>
            <param name="stream">要写入的流。</param>
            <param name="encoding">要使用的字符编码。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 null。</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream" /> 不可写。</exception>
        </member>
        <member name="M:NewLife.IO.StreamWriterX.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>用指定的编码及缓冲区大小，为指定的流初始化 <see cref="T:System.IO.StreamWriter" /> 类的新实例。</summary>
            <param name="stream">要写入的流。</param>
            <param name="encoding">要使用的字符编码。</param>
            <param name="closable">是否关闭数据流。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 null。</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream" /> 不可写。</exception>
        </member>
        <member name="P:NewLife.IO.StreamWriterX.Closable">
            <summary>是否在最后关闭流</summary>
        </member>
        <member name="T:NewLife.Common.SysConfig">
            <summary>系统设置。提供系统名称、版本等基本设置。</summary>
        </member>
        <member name="T:NewLife.Common.SysConfig`1">
            <summary>系统设置。提供系统名称、版本等基本设置。泛型基类，可继承扩展。</summary>
            <typeparam name="TSetting"></typeparam>
        </member>
        <member name="M:NewLife.Common.SysConfig`1.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="F:NewLife.Common.SysConfig`1.SysAssembly">
            <summary>系统主程序集</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Name">
            <summary>系统名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Version">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.DisplayName">
            <summary>显示名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Company">
            <summary>公司</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Tel">
            <summary>电话</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Fax">
            <summary>传真</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.EMail">
            <summary>电子邮件</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.IsEnable">
            <summary>是否启用</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.InstallTime">
            <summary>安装时间</summary>
        </member>
        <member name="T:NewLife.Runtime">
            <summary>运行时</summary>
        </member>
        <member name="M:NewLife.Runtime.GetPEFileKinds(System.Reflection.MemberInfo)">
            <summary>获取PE文件类型。扩展方法</summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Runtime.GetPEFileKinds(System.String)">
            <summary>Parses the PE header and determines whether the given assembly is a console application.</summary>
            <param name="assemblyPath">The path of the assembly to check.</param>
            <remarks>The magic numbers in this method are extracted from the PE/COFF file
            format specification available from http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx
            </remarks>
        </member>
        <member name="M:NewLife.Runtime.SetProcessWorkingSetSize(System.Int32,System.Int32,System.Int32)">
            <summary>设置进程的程序集大小，将部分物理内存占用转移到虚拟内存</summary>
            <param name="pid">要设置的进程ID</param>
            <param name="min">最小值</param>
            <param name="max">最大值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Runtime.ReleaseMemory">
            <summary>释放当前进程所占用的内存</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Runtime.IsConsole">
            <summary>是否控制台。用于判断是否可以执行一些控制台操作。</summary>
        </member>
        <member name="P:NewLife.Runtime.IsWeb">
            <summary>是否Web环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Is64BitOperatingSystem">
            <summary>确定当前操作系统是否为 64 位操作系统。</summary>
            <returns>如果操作系统为 64 位操作系统，则为 true；否则为 false。</returns>
        </member>
        <member name="P:NewLife.Runtime.Is64BitProcess">
            <summary>确定当前进程是否为 64 位进程。</summary>
            <returns>如果进程为 64 位进程，则为 true；否则为 false。</returns>
        </member>
        <member name="P:NewLife.Runtime.OSName">
            <summary>操作系统</summary>
        </member>
        <member name="T:NewLife.OSSuites">
            <summary>标识系统上的程序组</summary>
        </member>
        <member name="T:NewLife.OSProductType">
            <summary>标识系统类型</summary>
        </member>
        <member name="F:NewLife.OSProductType.WorkStation">
            <summary>工作站</summary>
        </member>
        <member name="F:NewLife.OSProductType.DomainController">
            <summary>域控制器</summary>
        </member>
        <member name="F:NewLife.OSProductType.Server">
            <summary>服务器</summary>
        </member>
        <member name="T:NewLife.Log.WriteLogEventArgs">
            <summary>写日志事件参数</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor">
            <summary>实例化一个日志事件参数</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String)">
            <summary>构造函数</summary>
            <param name="message">日志</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String,System.Exception)">
            <summary>构造函数</summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String,System.Exception,System.Boolean)">
            <summary>构造函数</summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
            <param name="isNewLine">是否换行</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(System.String,System.Exception,System.Boolean)">
            <summary>初始化为新日志</summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
            <param name="isNewLine">是否换行</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Clear">
            <summary>清空日志特别是异常对象，避免因线程静态而导致内存泄漏</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Message">
            <summary>日志信息</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsNewLine">
            <summary>是否换行</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadID">
            <summary>线程编号</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsPoolThread">
            <summary>是否线程池线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsWeb">
            <summary>是否Web线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadName">
            <summary>线程名</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Current">
            <summary>线程专有实例。线程静态，每个线程只用一个，避免GC浪费</summary>
        </member>
        <member name="T:NewLife.Reflection.ILInstruction">
            <summary>IL指令</summary>
        </member>
        <member name="M:NewLife.Reflection.ILInstruction.ToString">
            <summary>已重载。返回指令的字符串形式</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ILInstruction.FixType(System.Type)">
            <summary>取得类型的友好名</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.ILInstruction.Code">
            <summary>指令</summary>
        </member>
        <member name="P:NewLife.Reflection.ILInstruction.Operand">
            <summary>操作</summary>
        </member>
        <member name="P:NewLife.Reflection.ILInstruction.OperandData">
            <summary>操作数据</summary>
        </member>
        <member name="P:NewLife.Reflection.ILInstruction.Offset">
            <summary>偏移</summary>
        </member>
        <member name="T:NewLife.IO.IStreamHandler">
            <summary>数据流处理器接口</summary>
        </member>
        <member name="M:NewLife.IO.IStreamHandler.Process(System.IO.Stream)">
            <summary>处理数据流</summary>
            <param name="stream">待处理数据流</param>
            <returns>转发给下一个处理器的数据流，如果不想让后续处理器处理，返回空</returns>
        </member>
        <member name="P:NewLife.IO.IStreamHandler.IsReusable">
            <summary>是否可以重用。</summary>
        </member>
        <member name="T:NewLife.IO.StreamHandler">
            <summary>数据流处理器</summary>
        </member>
        <member name="M:NewLife.IO.StreamHandler.Process(System.IO.Stream)">
            <summary>处理数据流</summary>
            <param name="stream"></param>
            <returns>转发给下一个处理器的数据流，如果不想让后续处理器处理，返回空</returns>
        </member>
        <member name="M:NewLife.IO.StreamHandler.Register(System.String,NewLife.IO.IStreamHandler,System.Boolean)">
            <summary>
            注册数据流处理器。
            数据流到达时将进入指定通道的每一个处理器。
            不同通道名称的处理器互不干扰。
            不提供注册到指定位置的功能，如果需要，再以多态方式实现。
            </summary>
            <param name="name">通道名称，用于区分数据流总线</param>
            <param name="handler">数据流处理器</param>
            <param name="cover">是否覆盖原有同类型处理器</param>
        </member>
        <member name="M:NewLife.IO.StreamHandler.QueryRegister(System.String)">
            <summary>查询注册，返回指定通道的处理器数组。</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandler.GetHandler">
            <summary>获取配置文件指定的处理器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandler.LoadConfig">
            <summary>从配置文件中加载工厂</summary>
        </member>
        <member name="M:NewLife.IO.StreamHandler.Process(System.String,System.IO.Stream)">
            <summary>处理数据流。Http、Tcp、Udp等所有数据流都将到达这里，多种传输方式汇聚于此，由数据流总线统一处理！</summary>
            <param name="name"></param>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.IO.StreamHandler.IsReusable">
            <summary>是否可以重用</summary>
        </member>
        <member name="T:NewLife.IO.FileSource">
            <summary>文件资源</summary>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFile(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>释放文件</summary>
            <param name="asm"></param>
            <param name="filename"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFolder(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>释放文件夹</summary>
            <param name="asm"></param>
            <param name="prefix"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFolder(System.Reflection.Assembly,System.String,System.String,System.Boolean,NewLife.Reflection.Func{System.String,System.String})">
            <summary>释放文件夹</summary>
            <param name="asm"></param>
            <param name="prefix"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
            <param name="filenameResolver"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.GetFileResource(System.Reflection.Assembly,System.String)">
            <summary>获取文件资源</summary>
            <param name="asm"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Linq.IOrderedEnumerable`1">
            <summary>表示已排序序列。</summary>
            <typeparam name="TElement">序列中的元素的类型。</typeparam>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NewLife.Linq.IOrderedEnumerable`1.CreateOrderedEnumerable``1(NewLife.Reflection.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>根据某个键对 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" /> 的元素执行后续排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，其元素按键进行排序。</returns>
            <param name="keySelector">用于提取每个元素的键的 <see cref="T:System.Func`2" />。</param>
            <param name="comparer">用于比较键在返回序列中的位置的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
            <param name="descending">如果为 true，则对元素进行降序排序；如果为 false，则对元素进行升序排序。</param>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 生成的键的类型。</typeparam>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:NewLife.Linq.ILookup`2">
            <summary>定义索引器、大小属性以及将键映射到 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 值序列的数据结构的布尔搜索方法。</summary>
            <typeparam name="TKey">
              <see cref="T:NewLife.Linq.ILookup`2" /> 中的键的类型。</typeparam>
            <typeparam name="TElement">组成 <see cref="T:NewLife.Linq.ILookup`2" /> 中的值的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 序列中的元素的类型。</typeparam>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NewLife.Linq.ILookup`2.Contains(`0)">
            <summary>确定指定的键是否位于 <see cref="T:NewLife.Linq.ILookup`2" /> 中。</summary>
            <returns>如果 <paramref name="key" /> 在 <see cref="T:NewLife.Linq.ILookup`2" /> 中，则为 true；否则为 false。</returns>
            <param name="key">要在 <see cref="T:NewLife.Linq.ILookup`2" /> 中搜索的键。</param>
        </member>
        <member name="P:NewLife.Linq.ILookup`2.Count">
            <summary>Gets the number of key/value collection pairs in the <see cref="T:NewLife.Linq.ILookup`2" />.</summary>
            <returns>The number of key/value collection pairs in the <see cref="T:NewLife.Linq.ILookup`2" />.</returns>
        </member>
        <member name="P:NewLife.Linq.ILookup`2.Item(`0)">
            <summary>获取按指定键进行索引的值的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 序列。</summary>
            <returns>按指定键进行索引的值的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 序列。</returns>
            <param name="key">所需值序列的键。</param>
        </member>
        <member name="T:System.EnumHelper">
            <summary>枚举类型助手类</summary>
        </member>
        <member name="M:System.EnumHelper.Has(System.Enum,System.Enum)">
            <summary>枚举变量是否包含指定标识</summary>
            <param name="value">枚举变量</param>
            <param name="flag">要判断的标识</param>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.Set``1(System.Enum,``0,System.Boolean)">
            <summary>设置标识位</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="flag"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.GetDescription(System.Enum)">
            <summary>获取枚举字段的注释</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.GetDescriptions``1">
            <summary>获取枚举类型的所有字段注释</summary>
            <typeparam name="TEnum"></typeparam>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.GetDescriptions(System.Type)">
            <summary>获取枚举类型的所有字段注释</summary>
            <param name="enumType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.CompressionModule">
            <summary>页面压缩模块</summary>
        </member>
        <member name="M:NewLife.Web.CompressionModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.CompressionModule.IsEncodingAccepted(System.String)">
            <summary>检查请求头，确认客户端是否支持压缩编码</summary>
        </member>
        <member name="M:NewLife.Web.CompressionModule.SetEncoding(System.String)">
            <summary>添加压缩编码到响应头</summary>
            <param name="encoding"></param>
        </member>
        <member name="T:NewLife.Serialization.BinaryWriterX">
            <summary>二进制写入器</summary>
            <remarks>
            序列化框架的核心思想：基本类型直接写入，自定义类型反射得到成员，逐层递归写入！详见<see cref="T:NewLife.Serialization.IReaderWriter"/>
            
            二进制序列化，并不仅仅是为了序列化一个对象那么简单，它最初的目标是实现一个高度可自定义的序列化组件，后来提升为以序列化各种协议为重点。
            理论上，只要用实体类实现了各种协议（文件格式），那么它就能只用一个Read/Write实现协议实体对象与二进制数据流之间的映射。
            
            Decimal转为四个Int32整数然后编码输出；
            DateTime转为Int64然后编码输出。
            </remarks>
            <example>
            标准用法：
            <code>
            var writer = new BinaryWriterX();
            writer.Stream = stream;
            writer.WriteObject(entity);
            </code>
            </example>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.#ctor">
            <summary>实例化一个二进制写入器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.#ctor(System.IO.Stream)">
            <summary>实例化一个二进制写入器</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteIntBytes(System.Byte[])">
            <summary>判断字节顺序</summary>
            <param name="buffer"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEncoded(System.Int16)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEncoded(System.Int32)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEncoded(System.Int64)">
            <summary>
            以7位压缩格式写入64位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.GetEncodedIntSize(System.Int64)">
            <summary>获取整数编码后所占字节数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnWriteType(System.Type)">
            <summary>写入Type</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteRefObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写引用对象</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteObjRef(System.Object)">
            <summary>写入对象引用。</summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnWriteMember(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入对象成员</summary>
            <param name="name">成员名字</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举数据，复杂类型使用委托方法进行处理</summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnGetMembers(System.Type,System.Object)">
            <summary>获取需要序列化的成员（属性或字段）</summary>
            <param name="type">指定类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnWriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Flush">
            <summary>刷新缓存中的数据</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.EnableTraceStream">
            <summary>使用跟踪流</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="P:NewLife.Serialization.BinaryWriterX.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryWriterX.Stream">
            <summary>数据流。更改数据流后，重置Writer为空，以使用新的数据流</summary>
        </member>
        <member name="T:System.Runtime.TargetedPatchingOptOutAttribute">
            <summary>指示此特性应用于的 .NET Framework 类库方法不可能受服务版本的影响，因此它可以在本机映像生成器 (NGen) 格式的映像间内联。</summary>
        </member>
        <member name="M:System.Runtime.TargetedPatchingOptOutAttribute.#ctor(System.String)">
            <summary>初始化 <see cref="T:System.Runtime.TargetedPatchingOptOutAttribute" /> 类的新实例。</summary>
            <param name="reason">
              <see cref="T:System.Runtime.TargetedPatchingOptOutAttribute" /> 特性应用于的方法被认为可以在本机映像生成器 (NGen) 格式的映像间内联的原因。</param>
        </member>
        <member name="P:System.Runtime.TargetedPatchingOptOutAttribute.Reason">
            <summary>获取此特性应用于的方法被认为可以在本机映像生成器 (NGen) 格式的映像间内联的原因。</summary>
            <returns>此方法被认为可以在 NGen 格式的映像间内联的原因。</returns>
        </member>
        <member name="T:NewLife.Linq.Lookup`2">
            <summary>表示映射到一个或多个值的各个键的集合。</summary>
            <typeparam name="TKey">
              <see cref="T:NewLife.Linq.Lookup`2" /> 中的键的类型。</typeparam>
            <typeparam name="TElement">
              <see cref="T:NewLife.Linq.Lookup`2" /> 中的每个 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 值的元素的类型。</typeparam>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NewLife.Linq.Lookup`2.Contains(`0)">
            <summary>确定指定的键是否位于 <see cref="T:NewLife.Linq.Lookup`2" /> 中。</summary>
            <returns>如果 <paramref name="key" /> 在 <see cref="T:NewLife.Linq.Lookup`2" /> 中，则为 true；否则为 false。</returns>
            <param name="key">要在 <see cref="T:NewLife.Linq.Lookup`2" /> 中查找的键。</param>
        </member>
        <member name="M:NewLife.Linq.Lookup`2.GetEnumerator">
            <summary>返回循环访问 <see cref="T:NewLife.Linq.Lookup`2" /> 的泛型枚举数。</summary>
            <returns>
              <see cref="T:NewLife.Linq.Lookup`2" /> 的枚举数。</returns>
        </member>
        <member name="M:NewLife.Linq.Lookup`2.ApplyResultSelector``1(NewLife.Reflection.Func{`0,System.Collections.Generic.IEnumerable{`1},``0})">
            <summary>对每个键及其关联值应用转换函数，并返回结果。</summary>
            <returns>包含 <see cref="T:NewLife.Linq.Lookup`2" /> 中的各个键/值对集合中的一个值的集合。</returns>
            <param name="resultSelector">从每个键及其关联值投影结果值的函数。</param>
            <typeparam name="TResult">
              <paramref name="resultSelector" /> 生成的结果值的类型。</typeparam>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NewLife.Linq.Lookup`2.Count">
            <summary>获取 <see cref="T:NewLife.Linq.Lookup`2" /> 中的键/值对集合的数目。</summary>
            <returns>
              <see cref="T:NewLife.Linq.Lookup`2" /> 中键/值对集合的数目。</returns>
        </member>
        <member name="P:NewLife.Linq.Lookup`2.Item(`0)">
            <summary>获取按指定键进行索引的值的集合。</summary>
            <returns>按指定键进行索引的值的集合。</returns>
            <param name="key">所需值集合的键。</param>
        </member>
        <member name="T:NewLife.Linq.IGrouping`2">
            <summary>表示具有公共键的对象的集合。</summary>
            <typeparam name="TKey">
              <see cref="T:NewLife.Linq.IGrouping`2" /> 的键的类型。</typeparam>
            <typeparam name="TElement">
              <see cref="T:NewLife.Linq.IGrouping`2" /> 的值的类型。</typeparam>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NewLife.Linq.IGrouping`2.Key">
            <summary>获取 <see cref="T:NewLife.Linq.IGrouping`2" /> 的键。</summary>
            <returns>
              <see cref="T:NewLife.Linq.IGrouping`2" /> 的键。</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.ExtensionAttribute">
            <summary>支持使用扩展方法的特性</summary>
            <remarks>
            为了能在vs2010+.Net 2.0中使用扩展方法，添加该特性。
            在vs2010+.Net4.0中引用当前程序集，会爆一个预定义类型多次定义的警告，不影响使用。
            2011-11-15
            @补丁 建议独立NewLife.Linq.dll以规避.Net 4.0中冲突的问题。
            但仔细想想，不管分两个DLL还是何在一起，还是会冲突的，除非所有组件都编译两份，其中一份For .Net 4.0不需要这个扩展方法的。
            在@Aimeast和@小董 的帮助下，决定枚举器扩展的命名空间从System.Linq改为NewLife.Linq。
            </remarks>
        </member>
        <member name="T:NewLife.Messaging.HttpClientMessageProvider">
            <summary>Http客户端消息提供者</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageProvider">
            <summary>消息提供者基类</summary>
        </member>
        <member name="T:NewLife.Messaging.IMessageProvider">
            <summary>消息提供者接口</summary>
            <remarks>
            同步结构使用<see cref="M:NewLife.Messaging.IMessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)"/>；
            异步结构使用<see cref="M:NewLife.Messaging.IMessageProvider.Send(NewLife.Messaging.Message)"/>和<see cref="E:NewLife.Messaging.IMessageProvider.OnReceived"/>；
            异步结构中也可以使用<see cref="M:NewLife.Messaging.IMessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)"/>，但是因为通过事件量完成，会极为不稳定。
            
            如果只需要操作某个通道的消息，可通过<see cref="M:IMessageConsumer Register(Byte channel)"/>实现。
            
            <see cref="M:NewLife.Messaging.IMessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)"/>适合客户端的大多数情况，比如同步Http、同步Tcp。
            如果内部实现是异步模型，则等待指定时间获取异步返回的第一条消息，该消息不再触发消息到达事件<see cref="E:NewLife.Messaging.IMessageProvider.OnReceived"/>。
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.IMessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)">
            <summary>发送并接收消息。主要用于应答式的请求和响应。该方法的实现不是线程安全的，使用时一定要注意。</summary>
            <remarks>如果内部实现是异步模型，则等待指定时间获取异步返回的第一条消息，该消息不再触发消息到达事件<see cref="E:NewLife.Messaging.IMessageProvider.OnReceived"/>。</remarks>
            <param name="message"></param>
            <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite"/> (-1)，表示无限期等待。默认0表示不等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessageProvider.Send(NewLife.Messaging.Message)">
            <summary>发送消息。如果有响应，可在消息到达事件<see cref="E:NewLife.Messaging.IMessageProvider.OnReceived"/>中获得。</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Messaging.IMessageProvider.Register(NewLife.Messaging.MessageKind,NewLife.Messaging.MessageKind)">
            <summary>注册消息消费者，仅消费指定范围的消息</summary>
            <param name="start">消息范围的起始</param>
            <param name="end">消息范围的结束</param>
            <returns>消息消费者</returns>
        </member>
        <member name="M:NewLife.Messaging.IMessageProvider.Register(NewLife.Messaging.MessageKind[])">
            <summary>注册消息消费者，仅消费指定范围的消息</summary>
            <param name="kinds">消息类型的集合</param>
            <returns>消息消费者</returns>
        </member>
        <member name="M:NewLife.Messaging.IMessageProvider.Register(System.Byte)">
            <summary>注册消息消费者，仅消费指定通道的消息</summary>
            <param name="channel">通道</param>
            <returns>消息消费者</returns>
        </member>
        <member name="P:NewLife.Messaging.IMessageProvider.MaxMessageSize">
            <summary>最大消息大小，超过该大小将分包发送。0表示不限制。</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessageProvider.AutoJoinGroup">
            <summary>是否自动组合<see cref="T:NewLife.Messaging.GroupMessage"/>消息。</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessageProvider.JoinGroupTimeout">
            <summary>组合组消息超时时间，毫秒。对于<see cref="T:NewLife.Messaging.GroupMessage"/>，如果后续包不能在当前时间之内到达，则认为超时，放弃该组。</summary>
        </member>
        <member name="E:NewLife.Messaging.IMessageProvider.OnReceived">
            <summary>消息到达时触发</summary>
        </member>
        <member name="M:NewLife.Messaging.IMessageProvider2.Process(NewLife.Messaging.Message,System.Object)">
            <summary>收到消息时调用该方法</summary>
            <param name="message">消息</param>
            <param name="remoteIdentity">远程标识</param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.Send(NewLife.Messaging.Message)">
            <summary>发送消息。如果有响应，可在消息到达事件<see cref="E:NewLife.Messaging.MessageProvider.OnReceived"/>中获得。这里会实现大消息分包。</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.OnSend(System.IO.Stream)">
            <summary>发送数据流。</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.Process(System.IO.Stream,System.Object,System.Object)">
            <summary>收到消息时调用该方法</summary>
            <param name="stream">数据流</param>
            <param name="state">用户状态</param>
            <param name="remoteIdentity">远程标识</param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.Process(NewLife.Messaging.Message,System.Object)">
            <summary>收到消息时调用该方法</summary>
            <param name="message">消息</param>
            <param name="remoteIdentity">远程标识</param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.JoinGroup(NewLife.Messaging.GroupMessage,System.Object)">
            <summary>组合组消息</summary>
            <param name="message">消息</param>
            <param name="remoteIdentity">远程标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)">
            <summary>发送并接收消息。主要用于应答式的请求和响应。</summary>
            <remarks>如果内部实现是异步模型，则等待指定时间获取异步返回的第一条消息，该消息不再触发消息到达事件<see cref="E:NewLife.Messaging.MessageProvider.OnReceived"/>。</remarks>
            <param name="message"></param>
            <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite"/> (-1)，表示无限期等待。默认0表示不等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.Register(System.Byte)">
            <summary>注册消息消费者，仅消费指定通道的消息</summary>
            <param name="channel">通道</param>
            <returns>消息消费者</returns>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.Register(NewLife.Messaging.MessageKind,NewLife.Messaging.MessageKind)">
            <summary>注册消息消费者，仅消费指定范围的消息</summary>
            <param name="start">消息范围的起始</param>
            <param name="end">消息范围的结束</param>
            <returns>消息消费者</returns>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.Register(NewLife.Messaging.MessageKind[])">
            <summary>注册消息消费者，仅消费指定范围的消息</summary>
            <param name="kinds">消息类型的集合</param>
            <returns>消息消费者</returns>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.MaxMessageSize">
            <summary>最大消息大小，超过该大小将分包发送。0表示不限制。</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.AutoJoinGroup">
            <summary>是否自动组合<see cref="T:NewLife.Messaging.GroupMessage"/>消息。</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.JoinGroupTimeout">
            <summary>组合组消息超时时间，毫秒。对于<see cref="T:NewLife.Messaging.GroupMessage"/>，如果后续包不能在当前时间之内到达，则认为超时，放弃该组。</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.Parent">
            <summary>消息提供者</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.Kinds">
            <summary>响应的消息类型集合</summary>
        </member>
        <member name="E:NewLife.Messaging.MessageProvider.OnReceived">
            <summary>消息到达时触发。这里将得到所有消息</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.Consumers2">
            <summary>消费者集合</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.Consumers">
            <summary>消费者集合</summary>
        </member>
        <member name="T:NewLife.Messaging.IMessageConsumer">
            <summary>消息消费接口</summary>
        </member>
        <member name="M:NewLife.Messaging.IMessageConsumer.SendAndReceive(NewLife.Messaging.Message,System.Int32)">
            <summary>发送并接收消息。主要用于应答式的请求和响应。该方法的实现不是线程安全的，使用时一定要注意。</summary>
            <remarks>如果内部实现是异步模型，则等待指定时间获取异步返回的第一条消息，该消息不再触发消息到达事件<see cref="E:NewLife.Messaging.IMessageConsumer.OnReceived"/>。</remarks>
            <param name="message"></param>
            <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite"/> (-1)，表示无限期等待。默认0表示不等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessageConsumer.Send(NewLife.Messaging.Message)">
            <summary>发送消息。如果有响应，可在消息到达事件<see cref="E:NewLife.Messaging.IMessageConsumer.OnReceived"/>中获得。</summary>
            <param name="message"></param>
        </member>
        <member name="E:NewLife.Messaging.IMessageConsumer.OnReceived">
            <summary>消息到达时触发</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessageConsumer.Channel">
            <summary>通道</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessageConsumer.Provider">
            <summary>消息提供者</summary>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.MessageConsumer2.Send(NewLife.Messaging.Message)">
            <summary>发送消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.MessageConsumer2.SendAndReceive(NewLife.Messaging.Message,System.Int32)">
            <summary>发送并接收消息。主要用于应答式的请求和响应。</summary>
            <remarks>如果内部实现是异步模型，则等待指定时间获取异步返回的第一条消息，该消息不再触发消息到达事件<see cref="E:NewLife.Messaging.MessageProvider.MessageConsumer2.OnReceived"/>。</remarks>
            <param name="message"></param>
            <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite"/> (-1)，表示无限期等待。默认0表示不等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.MessageConsumer2.Process(NewLife.Messaging.Message)">
            <summary>收到消息时调用该方法</summary>
            <param name="message"></param>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.MessageConsumer2.Channel">
            <summary>通道</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageProvider.MessageConsumer2.Provider">
            <summary>消息提供者</summary>
        </member>
        <member name="E:NewLife.Messaging.MessageProvider.MessageConsumer2.OnReceived">
            <summary>消息到达时触发。这里将得到所有消息</summary>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.MessageConsumer.Send(NewLife.Messaging.Message)">
            <summary>发送消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Messaging.MessageProvider.MessageConsumer.OnSend(System.IO.Stream)">
            <summary>发送数据流。</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.HttpClientMessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)">
            <summary>发送并接收消息。主要用于应答式的请求和响应。</summary>
            <param name="message"></param>
            <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。默认0表示不等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.HttpClientMessageProvider.OnSend(System.IO.Stream)">
            <summary>发送数据流。</summary>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.Messaging.HttpClientMessageProvider.Uri">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Messaging.HttpClientMessageProvider.Client">
            <summary>客户端</summary>
        </member>
        <member name="T:NewLife.Web.WebClientX">
            <summary>扩展的Web客户端</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetWebRequest(System.Uri)">
            <summary>重写获取请求</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetWebResponse(System.Net.WebRequest)">
            <summary>重写获取响应</summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor(System.Boolean,System.Boolean)">
            <summary>初始化常用的东西</summary>
            <param name="ie">是否模拟ie</param>
            <param name="iscompress">是否压缩</param>
        </member>
        <member name="P:NewLife.Web.WebClientX.Cookie">
            <summary>Cookie容器</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Timeout">
            <summary>超时，毫秒</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.AutomaticDecompression">
            <summary>自动解压缩模式。</summary>
        </member>
        <member name="T:NewLife.Web.ControlHelper">
            <summary>控件助手</summary>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControl``1(System.Web.UI.Control,System.String)">
            <summary>查找指定类型的子孙控件</summary>
            <typeparam name="T">目标控件类型</typeparam>
            <param name="control">父控件，从该控件开始向下进行广度搜索</param>
            <param name="id">控件ID，不指定表示不限制</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControlUp``1(System.Web.UI.Control,System.String)">
            <summary>查找指定控件附近的控件，向上搜索</summary>
            <typeparam name="T">目标控件类型</typeparam>
            <param name="control">指定控件</param>
            <param name="id">控件ID，不指定表示不限制</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControlInPage``1(System.String)">
            <summary>在页面查找指定ID的控件，采用反射字段的方法，避免遍历Controls引起子控件构造</summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControlByField``1(System.Web.UI.Control,System.String)">
            <summary>根据字段查找指定ID的控件，采用反射字段的方法，避免遍历Controls引起子控件构造</summary>
            <typeparam name="T"></typeparam>
            <param name="control">容器</param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindEventHandler(System.Web.UI.Control,System.String)">
            <summary>查找控件的事件</summary>
            <param name="control"></param>
            <param name="eventName"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.TimerX">
            <summary>不可重入的定时器。</summary>
            <remarks>
            为了避免系统的Timer可重入的问题，差别在于本地调用完成后才开始计算时间间隔。这实际上也是经常用到的。
            
            因为挂载在静态列表上，必须从外部主动调用<see cref="M:System.IDisposable.Dispose"/>才能销毁定时器。
            
            该定时器不能放入太多任务，否则适得其反！
            
            TimerX必须维持对象，否则很容易被GC回收。
            </remarks>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.WaitCallback,System.Object,System.Int32,System.Int32)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始</param>
            <param name="period">间隔周期</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.WaitCallback,System.Object,System.Int32,System.Int32,System.Boolean)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始</param>
            <param name="period">间隔周期</param>
            <param name="usethreadpool">是否使用线程池。对于耗时短小且比较频繁的操作，不好使用线程池，减少线程切换。</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerX.Callback">
            <summary>回调</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.State">
            <summary>用户数据</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.NextTime">
            <summary>下一次调用时间</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Timers">
            <summary>调用次数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Period">
            <summary>间隔周期</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.UseThreadPool">
            <summary>是否使用线程池。对于耗时短小且比较频繁的操作，不好使用线程池，减少线程切换。</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Calling">
            <summary>调用中</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Debug">
            <summary>是否开启调试，输出更多信息</summary>
        </member>
        <member name="T:NewLife.Threading.ThreadX">
            <summary>线程扩展</summary>
        </member>
        <member name="F:NewLife.Threading.ThreadX.internalEvent">
            <summary>内部控制事件</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Abort(System.Boolean)">
            <summary>取消</summary>
            <param name="onlytask">是否仅仅取消任务</param>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Dispose(System.Boolean)">
            <summary>释放资源。非用户代码调用时，仅释放非托管资源</summary>
            <param name="disposing">是否用户代码调用</param>
        </member>
        <member name="M:NewLife.Threading.ThreadX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadX.FindException``1(System.Exception)">
            <summary>查找指定类型的异常</summary>
            <typeparam name="T"></typeparam>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Task">
            <summary>任务</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.LastError">
            <summary>最后错误</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Running">
            <summary>是否正在处理任务</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.IsAlive">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.CanRelease">
            <summary>是否能够释放</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Thread">
            <summary>线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.StartTime">
            <summary>开始时间</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.AliveTime">
            <summary>活动时间</summary>
        </member>
        <member name="E:NewLife.Threading.ThreadX.OnTaskFinished">
            <summary>任务完成时</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="T:NewLife.Threading.TaskState">
            <summary>任务状态</summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Unstarted">
            <summary>未处理</summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Running">
            <summary>正在处理</summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Finished">
            <summary>已完成</summary>
        </member>
        <member name="T:NewLife.IO.HttpStreamClient">
            <summary>基于Http协议的数据流客户端</summary>
        </member>
        <member name="T:NewLife.IO.StreamClient">
            <summary>数据流客户端，用于与服务端的数据流处理器通讯</summary>
        </member>
        <member name="M:NewLife.IO.StreamClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.IO.StreamClient.#ctor(System.Uri)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.IO.StreamClient.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.IO.StreamClient.Send(System.Byte[])">
            <summary>同步发送数据</summary>
            <param name="data">待发送数据</param>
            <returns>服务端响应数据</returns>
        </member>
        <member name="M:NewLife.IO.StreamClient.SendAsync(System.Byte[])">
            <summary>异步发送数据，服务端响应数据将由数据流总线处理</summary>
            <param name="data">待发送数据</param>
        </member>
        <member name="M:NewLife.IO.StreamClient.Process(System.IO.Stream)">
            <summary>处理数据流</summary>
            <param name="stream"></param>
        </member>
        <member name="F:NewLife.IO.StreamClient._Stream">
            <summary>内部数据流</summary>
        </member>
        <member name="M:NewLife.IO.StreamClient.GetStream">
            <summary>获取用于收发数据的数据流</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.StreamClient.Uri">
            <summary>服务端地址</summary>
        </member>
        <member name="P:NewLife.IO.StreamClient.StreamHandlerName">
            <summary>数据流总线名称</summary>
        </member>
        <member name="T:NewLife.IO.StreamClient.InternalStream">
            <summary>内部数据流。重写输入行为，然后使用一个内存流作为输出。</summary>
        </member>
        <member name="T:NewLife.IO.ReadWriteStream">
            <summary>读写流。内部包含输入流和输出流两个流，实际读取从输入流读取，写入则写入到输出流</summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>初始化</summary>
            <param name="inputStream"></param>
            <param name="outputStream"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Flush">
            <summary>刷新输出流写入的数据</summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>从输入流中读取数据</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>在输入流中搜索</summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.SetLength(System.Int64)">
            <summary>设置输出流的长度</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>把数据写入到输出流中</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>开始异步读操作</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.EndRead(System.IAsyncResult)">
            <summary>等待挂起的异步读完成</summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>开始异步写操作</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.EndWrite(System.IAsyncResult)">
            <summary>等待挂起的异步写完成</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.CheckArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>检查参数</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.InputStream">
            <summary>输入流</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.OutputStream">
            <summary>输出流</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanRead">
            <summary>输入流是否可读</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanSeek">
            <summary>输入流是否可移动</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanWrite">
            <summary>输出流是否可写</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.Length">
            <summary>输入流总长度</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.Position">
            <summary>输入流位置</summary>
        </member>
        <member name="P:NewLife.IO.StreamClient.InternalStream.Client">
            <summary>数据流客户端</summary>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.#ctor(System.Uri)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.Send(System.Byte[])">
            <summary>同步发送数据</summary>
            <param name="data">待发送数据</param>
            <returns>服务端响应数据</returns>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.SendAsync(System.Byte[])">
            <summary>异步发送数据，服务端响应数据将由数据流总线处理</summary>
            <param name="data">待发送数据</param>
        </member>
        <member name="P:NewLife.IO.HttpStreamClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="T:NewLife.Reflection.ScriptEngine">
            <summary>脚本引擎</summary>
            <remarks>
            三大用法：
            1，单个表达式，根据参数计算表达式结果并返回
            2，多个语句，最后有返回语句
            3，多个方法，有一个名为Execute的静态方法作为入口方法
            
            脚本引擎禁止实例化，必须通过<see cref="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)"/>方法创建，以代码为键进行缓存，避免重复创建反复编译形成泄漏。
            其中<see cref="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)"/>方法的第二个参数为true表示前两种用法，为false表示第三种用法。
            </remarks>
            <example>
            最简单而完整的用法：
            <code>
            // 根据代码创建脚本实例，相同代码只编译一次
            var se = ScriptEngine.Create("a+b");
            // 如果Method为空说明未编译，可设置参数
            if (se.Method == null)
            {
                se.Parameters.Add("a", typeof(Int32));
                se.Parameters.Add("b", typeof(Int32));
            }
            // 脚本固定返回Object类型，需要自己转换
            var n = (Int32)se.Invoke(2, 3);
            Console.WriteLine("2+3={0}", n);
            </code>
            
            无参数快速调用：
            <code>
            var n = (Int32)ScriptEngine.Execute("2*3");
            </code>
            
            约定参数快速调用：
            <code>
            var n = (Int32)ScriptEngine.Execute("p0*p1", new Object[] { 2, 3 });
            Console.WriteLine("2*3={0}", n);
            </code>
            </example>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.#ctor(System.String,System.Boolean)">
            <summary>构造函数私有，禁止外部越过Create方法直接创建实例</summary>
            <param name="code">代码片段</param>
            <param name="isExpression">是否表达式，表达式将编译成为一个Main方法</param>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)">
            <summary>为指定代码片段创建脚本引擎实例。采用缓存，避免同一脚本重复创建引擎。</summary>
            <param name="code">代码片段</param>
            <param name="isExpression">是否表达式，表达式将编译成为一个Main方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String)">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.String[],System.Type[],System.Object[])">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <param name="names">参数名称</param>
            <param name="parameterTypes">参数类型</param>
            <param name="parameters">参数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <param name="parameters">参数名值对</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.Object[])">
            <summary>执行表达式，返回结果。参数名默认为p0/p1/p2/pn</summary>
            <param name="code"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.GenerateCode">
            <summary>生成代码。根据<see cref="P:NewLife.Reflection.ScriptEngine.Code"/>完善得到最终代码<see cref="P:NewLife.Reflection.ScriptEngine.FinalCode"/></summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Compile">
            <summary>编译</summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Compile(System.String,System.CodeDom.Compiler.CompilerParameters)">
            <summary>编译</summary>
            <param name="classCode"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Invoke(System.Object[])">
            <summary>按照传入参数执行代码</summary>
            <param name="parameters">参数</param>
            <returns>结果</returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.ParseNameSpace(System.String)">
            <summary>分析命名空间</summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Code">
            <summary>代码</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.IsExpression">
            <summary>是否表达式</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Parameters">
            <summary>参数集合。编译后就不可修改。</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.FinalCode">
            <summary>最终代码</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Method">
            <summary>根据代码编译出来可供直接调用的方法</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Mix">
            <summary>快速反射</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.NameSpaces">
            <summary>命名空间集合</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.ReferencedAssemblies">
            <summary>引用程序集集合</summary>
        </member>
        <member name="T:NewLife.Messaging.EntityMessage">
            <summary>指定类型的对象消息</summary>
            <remarks>
            一般用于打包单个对象，理论上，这是一个万能消息。
            需要注意的是：本消息的设计，允许通讯双方使用不同的类，只要这两个类继承相同的接口或者抽象类。
            不写长度，所以<see cref="T:NewLife.Messaging.Message"/>为空时后面不能有其它包
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.EntityMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.EntityMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.EntityMessage.Type">
            <summary>实体类型。可以是接口或抽象类型（要求对象容器能识别）</summary>
        </member>
        <member name="P:NewLife.Messaging.EntityMessage.Value">
            <summary>对象值</summary>
        </member>
        <member name="T:System.IO.PathHelper">
            <summary>路径操作帮助</summary>
        </member>
        <member name="M:System.IO.PathHelper.GetFullPath(System.String)">
            <summary>获取文件或目录的全路径，过滤相对目录</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.EnsureDirectory(System.String)">
            <summary>确保目录存在，若不存在则创建</summary>
            <param name="path">文件路径或目录路径（斜杠结尾）</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CombinePath(System.String,System.String)">
            <summary>合并路径</summary>
            <param name="path"></param>
            <param name="path2"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Triplet">
            <summary>三个一组</summary>
        </member>
        <member name="F:NewLife.Collections.Triplet.First">
            <summary>第一个</summary>
        </member>
        <member name="F:NewLife.Collections.Triplet.Second">
            <summary>第二个</summary>
        </member>
        <member name="F:NewLife.Collections.Triplet.Third">
            <summary>第三个</summary>
        </member>
        <member name="M:NewLife.Collections.Triplet.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Collections.Triplet.#ctor(System.Object,System.Object)">
            <summary>初始化</summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet.#ctor(System.Object,System.Object,System.Object)">
            <summary>初始化</summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Triplet`3">
            <summary>泛型三个一组</summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
        </member>
        <member name="F:NewLife.Collections.Triplet`3.First">
            <summary>第一个</summary>
        </member>
        <member name="F:NewLife.Collections.Triplet`3.Second">
            <summary>第二个</summary>
        </member>
        <member name="F:NewLife.Collections.Triplet`3.Third">
            <summary>第三个</summary>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.#ctor(`0,`1)">
            <summary>初始化</summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.#ctor(`0,`1,`2)">
            <summary>初始化</summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.HttpModuleLoader">
            <summary>子目录HttpModule加载模块。用于加载子目录web.config中配置的IHttpModule。</summary>
            <remarks>
            将来的系统设计将会朝着模块化的方向发展，每个模块一个独立的子目录，最好包括配置文件的所有内容也一起在里面
            </remarks>
        </member>
        <member name="M:NewLife.Web.HttpModuleLoader.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.HttpModuleLoader.Process">
            <summary>根据路径判断是否加载</summary>
        </member>
        <member name="T:NewLife.Web.ErrorModule">
            <summary>全局错误处理模块</summary>
        </member>
        <member name="M:NewLife.Web.ErrorModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.ErrorModule.NeedProcess(System.Exception)">
            <summary>是否需要处理</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ErrorModule.OnError(System.Object,System.EventArgs)">
            <summary>错误处理方法</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Web.ErrorModule.OnErrorComplete">
            <summary>错误处理完成后执行。一般用于输出友好错误信息</summary>
        </member>
        <member name="T:NewLife.Web.IErrorInfoProvider">
            <summary>错误信息提供者。用于为错误处理模块提供扩展信息</summary>
        </member>
        <member name="M:NewLife.Web.IErrorInfoProvider.AddInfo(System.Exception,System.Text.StringBuilder)">
            <summary>为指定错误添加附加错误信息。需要自己格式化并加换行</summary>
            <param name="ex"></param>
            <param name="builder"></param>
        </member>
        <member name="T:NewLife.Serialization.ReadObjectEventArgs">
            <summary>读取对象事件参数</summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderEventArgs">
            <summary>读取器事件参数</summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderEventArgs.#ctor(NewLife.Serialization.ReadObjectCallback)">
            <summary>实例化</summary>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReaderEventArgs.Callback">
            <summary>处理成员的委托</summary>
        </member>
        <member name="M:NewLife.Serialization.ReadObjectEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.ReadObjectCallback)">
            <summary>实例化</summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadObjectEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadObjectEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonSettings">
            <summary>Json设置</summary>
        </member>
        <member name="T:NewLife.Serialization.TextReaderWriterSetting">
            <summary>文本读写器设置</summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterSetting">
            <summary>序列化设置</summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting._BaseDateTime">
            <summary>编码时间日期的起始时间，固定1970-01-01</summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterSetting.ConvertDateTimeToInt64(System.DateTime)">
            <summary>转换时间为64位整数，默认返回毫秒数,具体返回值取决于DateTimeFormat成员的值</summary>
            <param name="value">时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterSetting.ConvertInt64ToDateTime(System.Int64)">
            <summary>转换64位整数为时间</summary>
            <param name="value">64位整数</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.Encoding">
            <summary>字符串编码</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.UseTypeFullName">
            <summary>是否使用类型全名。类型全名能比程序集唯一名更节省空间</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.UseObjRef">
            <summary>是否使用对象引用。对于二进制读写，如果不使用对象引用，则不允许出现null对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.AutoFlush">
            <summary>自动刷新输出</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.UseField">
            <summary>是否使用字段作为处理成员。</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.IsBaseFirst">
            <summary>是否优先处理基类的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.DateTimeFormat">
            <summary>时间日期格式</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.BaseDateTime">
            <summary>编码时间日期的起始时间</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.SizeFormat">
            <summary>大小格式。只能是数字，无符号整数表示使用相应的压缩编码，压缩编码仅二进制序列化有效</summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats">
            <summary>时间日期格式</summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats.Ticks">
            <summary>嘀嗒数。相对较精确，但是占用空间较大,非utc时间</summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats.Milliseconds">
            <summary>毫秒数。Json常用格式.指定时间格式为与UTC时间1970.1.1 0:0:0之间的毫秒数</summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats.Seconds">
            <summary>秒数。相对较不准确，但占用空间最小，能满足日常要求.指定时间格式为与UTC时间1970.1.1 0:0:0之间的秒数</summary>
        </member>
        <member name="M:NewLife.Serialization.TextReaderWriterSetting.#ctor">
            <summary>实例化一个文本读写器设置</summary>
        </member>
        <member name="P:NewLife.Serialization.TextReaderWriterSetting.UseBase64">
            <summary>使用Base64编码字符串，否则使用十六进制字符串</summary>
        </member>
        <member name="P:NewLife.Serialization.TextReaderWriterSetting.UseEnumName">
            <summary>是否使用名称表示枚举类型，默认使用名称</summary>
        </member>
        <member name="P:NewLife.Serialization.TextReaderWriterSetting.WriteType">
            <summary>是否输出类型</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonSettings.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.Indent">
            <summary>缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.DateTimeMode">
            <summary>指定日期时间输出成什么时间,本地还是UTC时间,默认是UTC时间</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.JsonDateTimeFormat">
            <summary>指定日期时间输出成什么格式,具体格式说明见<see cref="T:NewLife.Serialization.JsonDateTimeFormats"/>,默认是ISO8601格式</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.UseStringUnicodeEncode">
            <summary>
            是否编码字符串中Unicode字符为\uXXXX的格式
            
            可以避免乱码问题,但是会增加数据长度
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.AllowMultiline">
            <summary>是否允许输出多行结果,这会便于阅读结果,当为false时可以用作jsonp回调(还需要做字符串转义)</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.DuplicatedObjectWriteMode">
            <summary>重复对象的处理方式,仅用于JsonWriter,默认是深度限制,使用DepthLimit执行的深度</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.DepthLimit">
            <summary>
            复合对象的解析深度限制,只有在DuplicatedObjectWriteMode是DuplicatedObjectWriteMode.DepthLimit时生效
            
            复合对象主要是[]和{}的对象,可能是数组 集合 字典 自定义类型
            
            对于JsonWriter,默认值是16(调试时5). 对于JsonReader,默认值是1000(调试时10)
            
            关于1000的取值,测试调用堆栈极限程序中大概12273次调用时抛出StackOverflowException异常,而每处理一个ReadObject大概需要9个调用
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.UseCharsWriteToString">
            <summary>是否将char[]输出为string,这会减少数据长度,仅会影响JsonWriter,默认true</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonDateTimeFormats">
            <summary>json序列化时用于指定日期时间输出成什么格式</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonDateTimeFormats.ISO8601">
            <summary>
            ISO 8601格式 类似"2011-05-05T05:12:19.123Z"格式的UTC时间
            
            在http://goo.gl/RZoaz中有js端实现,并且在ie8(ie8模式) ff3.5之后都内建提供toJSON()实现
            
            这也是默认格式
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonDateTimeFormats.DotnetDateTick">
            <summary>
            dotnet3.5中System.Web.Script.Serialization.JavaScriptSerializer输出的格式
            
            类似"\/Date(1304572339844)\/"格式的从 UTC 1970.1.1 午夜开始已经经过的毫秒数
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonDateTimeFormats.Tick">
            <summary>数字,具体值依赖于DateTimeFormat的配置</summary>
        </member>
        <member name="T:NewLife.Serialization.DuplicatedObjectWriteMode">
            <summary>重复对象的处理方式</summary>
        </member>
        <member name="F:NewLife.Serialization.DuplicatedObjectWriteMode.DepthLimit">
            <summary>限制处理复合对象的深度</summary>
        </member>
        <member name="F:NewLife.Serialization.DuplicatedObjectWriteMode.ObjectRef">
            <summary>对象引用方式,暂未实现</summary>
        </member>
        <member name="T:NewLife.Configuration.Config">
            <summary>通用配置辅助类</summary>
            <remarks>
            一定要注意的是：ConfigurationManager.AppSettings会获取当前应用的设置，如果子目录里面的web.config有设置，则会获取最近的设置。
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.Config.GethttpHandlers">
            <summary>获取httpHandlers</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.Contain(System.String)">
            <summary>是否包含指定项的设置</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetMutilConfig``1(``0,System.String[])">
            <summary>依次尝试获取一批设置项，直到找到第一个为止</summary>
            <typeparam name="T"></typeparam>
            <param name="defaultValue"></param>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.TryGetMutilConfig``1(``0@,System.String[])">
            <summary>依次尝试获取一批设置项，直到找到第一个为止</summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfig``1(System.String)">
            <summary>取得指定名称的设置项，并转为指定类型</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfig``1(System.String,``0)">
            <summary>取得指定名称的设置项，并转为指定类型。如果设置不存在，则返回默认值</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.TryGetConfig``1(System.String,``0@)">
            <summary>尝试获取指定名称的设置项</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.TryGetConfig(System.String,System.Type,System.Object@)">
            <summary>尝试获取指定名称的设置项</summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigByPrefix(System.String)">
            <summary>根据指定前缀，获取设置项。其中key不包含前缀</summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigSplit``1(System.String,System.String)">
            <summary>取得指定名称的设置项，并分割为指定类型数组</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigSplit``1(System.String,System.String,``0[])">
            <summary>取得指定名称的设置项，并分割为指定类型数组</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="split"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.SetConfig``1(System.String,``0)">
            <summary>设置配置文件参数</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:NewLife.Configuration.Config.SetConfig(System.String,System.String)">
            <summary>设置配置文件参数</summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.Config.AppSettingsKeyExists(System.String,System.Configuration.Configuration)">
            <summary>
            判断appSettings中是否有此项
            </summary>
        </member>
        <member name="M:NewLife.Configuration.Config.UpdateConfig(System.String,System.String)">
            <summary>设置配置文件参数</summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="P:NewLife.Configuration.Config.AppSettings">
            <summary>应用设置</summary>
        </member>
        <member name="P:NewLife.Configuration.Config.ConnectionStrings">
            <summary>连接字符串设置</summary>
        </member>
        <member name="P:NewLife.Configuration.Config.httpHandlers">
            <summary>获取httphandlers</summary>
        </member>
        <member name="T:NewLife.Model.IPlugin">
            <summary>通用插件接口</summary>
            <remarks>
            为了方便构建一个简单通用的插件系统，先规定如下：
            1，负责加载插件的宿主，在加载插件后会进行插件实例化，此时可在插件构造函数中做一些事情，但不应该开始业务处理，因为宿主的准备工作可能尚未完成
            2，宿主一切准备就绪后，会顺序调用插件的Init方法，并将宿主标识传入，插件通过标识区分是否自己的目标宿主。插件的Init应尽快完成。
            3，如果插件实现了<see cref="T:System.IDisposable"/>接口，宿主最后会清理资源。
            </remarks>
        </member>
        <member name="M:NewLife.Model.IPlugin.Init(System.String,System.IServiceProvider)">
            <summary>初始化</summary>
            <param name="identity">插件宿主标识</param>
            <param name="provider">服务提供者</param>
            <returns>返回初始化是否成功。如果当前宿主不是所期待的宿主，这里返回false</returns>
        </member>
        <member name="T:NewLife.Model.PluginAttribute">
            <summary>插件特性。用于判断某个插件实现类是否支持某个宿主</summary>
        </member>
        <member name="M:NewLife.Model.PluginAttribute.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="identity"></param>
        </member>
        <member name="P:NewLife.Model.PluginAttribute.Identity">
            <summary>插件宿主标识</summary>
        </member>
        <member name="T:NewLife.Model.PluginManager">
            <summary>插件管理器</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor">
            <summary>实例化一个插件管理器</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor(System.Object)">
            <summary>使用宿主对象实例化一个插件管理器</summary>
            <param name="host"></param>
        </member>
        <member name="M:NewLife.Model.PluginManager.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.Model.PluginManager.Load">
            <summary>加载插件。此时是加载所有插件，无法识别哪些是需要的</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.Init">
            <summary>开始初始化。初始化之后，不属于当前宿主的插件将会被过滤掉</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Identity">
            <summary>宿主标识，用于供插件区分不同宿主</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Provider">
            <summary>宿主服务提供者</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Plugins">
            <summary>插件集合</summary>
        </member>
        <member name="T:NewLife.Xml.XmlReaderX">
            <summary>Xml读取器</summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.#ctor(System.String)">
            <summary>使用xml字符串初始化</summary>
            <param name="xml"></param>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadString">
            <summary>从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadChar">
            <summary>从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadDateTime">
            <summary>读取一个时间日期</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadValue(System.Type,System.Object@)">
            <summary>尝试读取值类型数据，返回是否读取成功</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadType">
            <summary>读对象类型</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取字典类型对象</summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取字典项</summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="value">字典项</param>
            <param name="index">元素序号</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取枚举</summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取枚举项</summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取目标对象指定成员的值，通过委托方法递归处理成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadRefObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>尝试读取引用对象</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>读取成员之前获取要读取的成员，默认是index处的成员，实现者可以重载，改变当前要读取的成员，如果当前成员不在数组里面，则实现者自己跳到下一个可读成员。</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="members">可匹配成员数组</param>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取对象成员</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadObjRefIndex">
            <summary>读取对象引用计数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadUnKnown(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.SkipEmpty">
            <summary>当前节点是否空。如果是空节点，则读一次，让指针移到下一个元素</summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadLengths">
            <summary>读取多维数组相关参数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>读取实现了可序列化接口的对象</summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.Stream">
            <summary>数据流。更改数据流后，重置Reader为空，以使用新的数据流</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.EndOfStream">
            <summary>获取一个值，该值表示当前的流位置是否在流的末尾。</summary>
            <returns>如果当前的流位置在流的末尾，则为 true；否则为 false。</returns>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.RootName">
            <summary>根元素名</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.Lengths">
            <summary>多维数组长度</summary>
        </member>
        <member name="T:NewLife.Security.DataHelper">
            <summary>数据助手</summary>
        </member>
        <member name="M:NewLife.Security.DataHelper.Hash(System.String)">
            <summary>MD5散列</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.HashFile(System.String)">
            <summary>文件散列</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC16(System.IO.Stream)">
            <summary>CRC校验</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC16(System.Byte[])">
            <summary>CRC校验</summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC16(System.String)">
            <summary>CRC校验文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC32(System.IO.Stream)">
            <summary>CRC校验</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC32(System.Byte[])">
            <summary>CRC校验</summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC32(System.String)">
            <summary>CRC校验文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Encrypt(System.String,System.String)">
            <summary>TripleDES加密</summary>
            <param name="content">UTD8编码的明文</param>
            <param name="key">密码字符串经MD5散列后作为DES密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Encrypt(System.Byte[],System.String)">
            <summary>TripleDES加密</summary>
            <param name="data"></param>
            <param name="key">密码字符串经MD5散列后作为DES密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Descrypt(System.String,System.String)">
            <summary>TripleDES解密</summary>
            <param name="content">UTD8编码的密文</param>
            <param name="key">密码字符串经MD5散列后作为DES密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Descrypt(System.Byte[],System.String)">
            <summary>TripleDES解密</summary>
            <param name="data"></param>
            <param name="key">密码字符串经MD5散列后作为DES密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.RC4(System.Byte[],System.String)">
            <summary>RC4加密解密</summary>
            <param name="data">数据</param>
            <param name="pass">UTF8编码的密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.GetKey(System.Byte[],System.Int32)">
            <summary>打乱密码</summary>
            <param name="pass">密码</param>
            <param name="kLen">密码箱长度</param>
            <returns>打乱后的密码</returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Sign(System.Byte[],System.String)">
            <summary>签名</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns>Base64编码的签名</returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Verify(System.Byte[],System.String,System.String)">
            <summary>验证签名</summary>
            <param name="data">待验证的数据</param>
            <param name="signdata">Base64编码的签名</param>
            <param name="pubKey">公钥</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.ToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.FromHex(System.String)">
            <summary>解密</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XSerializationException">
            <summary>序列化异常</summary>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(System.String,System.String)">
            <summary>初始化</summary>
            <param name="member"></param>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(System.String,System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="member"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="member"></param>
            <param name="innerException"></param>
        </member>
        <member name="P:NewLife.Serialization.XSerializationException.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.XSerializationException.Value">
            <summary>对象值</summary>
        </member>
        <member name="T:NewLife.Serialization.WriteMemberEventArgs">
            <summary>写入成员事件参数</summary>
        </member>
        <member name="M:NewLife.Serialization.WriteMemberEventArgs.#ctor(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>实例化</summary>
            <param name="name">成员名字</param>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="index">成员序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Name">
            <summary>成员名称</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Index">
            <summary>成员序号</summary>
        </member>
        <member name="T:NewLife.Serialization.NameValueWriter">
            <summary>名值写入器。用于Http请求、Http接口响应、Cookie值等读写操作。</summary>
        </member>
        <member name="M:NewLife.Serialization.NameValueWriter.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.NameValueWriter.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="P:NewLife.Serialization.NameValueWriter.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Serialization.NameValueWriter.Stream">
            <summary>数据流。更改数据流后，重置Writer为空，以使用新的数据流</summary>
        </member>
        <member name="T:NewLife.Serialization.ReadObjectCallback">
            <summary>数据读取方法</summary>
            <param name="reader">读取器</param>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="T:NewLife.Serialization.NameValueReader">
            <summary>名值读取器。用于Http请求、Http接口响应、Cookie值等读写操作。</summary>
        </member>
        <member name="M:NewLife.Serialization.NameValueReader.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.NameValueReader.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="P:NewLife.Serialization.NameValueReader.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Serialization.NameValueReader.Stream">
            <summary>数据流。更改数据流后，重置Reader为空，以使用新的数据流</summary>
        </member>
        <member name="T:NewLife.Messaging.DataMessage">
            <summary>指定长度的字节数据消息</summary>
            <remarks>
            一般用于对数据进行二次包装，理论上，这是一个万能消息。
            数据长度由<see cref="P:NewLife.Messaging.DataMessage.Data"/>决定，以编码整数来存储。
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.DataMessage.OnWrite(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>已重载。</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="M:NewLife.Messaging.DataMessage.OnReadWriteSet(NewLife.Serialization.IReaderWriter)">
            <summary>读写前设置。不使用对象引用</summary>
            <param name="rw"></param>
        </member>
        <member name="M:NewLife.Messaging.DataMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.DataMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.DataMessage.Data">
            <summary>数据</summary>
        </member>
        <member name="T:NewLife.Collections.SafeStack`1">
            <summary>基于数组实现的线程安全栈。快速高效，不会形成内存碎片。</summary>
            <remarks>
            链表做的原子栈<see cref="T:NewLife.Collections.InterlockedStack`1"/>，本来是为了做对象池用的，但是链表节点自身也会形成内存碎片，给GC压力，十分纠结。
            一直认为用数组做存储是效率最好的，但是纠结于无法实现原子操作，而迟迟不敢动手。
            
            最好指定初始容量，因为采用数组作为存储结构最大的缺点就是容量固定，从而导致满存储时必须重新分配数组，并且复制。
            
            在 @Aimeast 的指点下，有所感悟，我们没必要严格的追求绝对安全，只要把冲突可能性降到尽可能低即可。
            
            安全栈有问题，如果在同一个位置同时压入和弹出，可能会导致这个位置为空，后面再弹出的时候，只得到空值。
            通过增加一个锁定数组来解决这个问题，锁定数组实现不严格的数字对比锁定，保证性能。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NewLife.Collections.IStack`1">
            <summary>栈接口</summary>
            <remarks>重点解决多线程环境下资源争夺以及使用lock造成性能损失的问题</remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.IStack`1.Push(`0)">
            <summary>向栈压入一个对象</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.IStack`1.Pop">
            <summary>从栈中弹出一个对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.IStack`1.TryPop(`0@)">
            <summary>尝试从栈中弹出一个对象</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Collections.SafeStack`1._array">
            <summary>数据数组。用于存放对象。</summary>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.#ctor">
            <summary>实例化一个容纳4个元素的安全栈</summary>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.#ctor(System.Int32)">
            <summary>实例化一个指定大小的安全栈</summary>
            <param name="capacity"></param>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.#ctor(System.Collections.IEnumerable)">
            <summary>使用指定枚举实例化一个安全栈</summary>
            <param name="collection"></param>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.Push(`0)">
            <summary>向栈压入一个对象</summary>
            <remarks>重点解决多线程环境下资源争夺以及使用lock造成性能损失的问题</remarks>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.Pop">
            <summary>从栈中弹出一个对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.TryPop(`0@)">
            <summary>尝试从栈中弹出一个对象</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.Clear">
            <summary>清空</summary>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.ToArray">
            <summary>转为数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.SafeStack`1.GetEnumerator">
            <summary>获取枚举器</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.SafeStack`1.Count">
            <summary>元素个数，同时也是下一个空位的位置指针</summary>
        </member>
        <member name="P:NewLife.Collections.SafeStack`1.Capacity">
            <summary>最大容量</summary>
        </member>
        <member name="T:NewLife.Collections.ISafeStackItem">
            <summary>安全栈项接口。采用安全栈存储的数据必须实现该接口</summary>
        </member>
        <member name="P:NewLife.Collections.ISafeStackItem.Slot">
            <summary>存储位置</summary>
        </member>
        <member name="T:NewLife.EventArgs`1">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`1.#ctor(`0)">
            <summary>使用参数初始化</summary>
            <param name="arg"></param>
        </member>
        <member name="M:NewLife.EventArgs`1.Pop(`0@)">
            <summary>弹出</summary>
            <param name="arg"></param>
        </member>
        <member name="P:NewLife.EventArgs`1.Arg">
            <summary>参数</summary>
        </member>
        <member name="T:NewLife.EventArgs`2">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`2.#ctor(`0,`1)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:NewLife.EventArgs`2.Pop(`0@,`1@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="T:NewLife.EventArgs`3">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:NewLife.EventArgs`3.Pop(`0@,`1@,`2@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="T:NewLife.EventArgs`4">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="M:NewLife.EventArgs`4.Pop(`0@,`1@,`2@,`3@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg4">
            <summary>参数4</summary>
        </member>
        <member name="T:NewLife.Threading.ReadWriteLock">
            <summary>原子读写锁</summary>
            <remark>
            任意多个读操作，有限个<see cref="P:NewLife.Threading.ReadWriteLock.Max"/>写操作；
            任意读操作阻塞写操作，同样任意写操作阻塞非本线程读操作和其它写操作；
            </remark>
            <remarks>
            do...while(Interlocked.CompareExchange(ref _lock, oldLock - 1, oldLock) != oldLock)形式的原子锁结构，
            精髓在于do...while之间，里面才是真正的判断数据有效性核心，而CompareExchange仅仅是负责完成替换而已。
            实际上，就类似于准备好各种资料等上级审批，而上级每次只能审批一个，如果这次别人抢到了，那么自己得再次准备资料。
            </remarks>
        </member>
        <member name="F:NewLife.Threading.ReadWriteLock._lock">
            <summary>锁计数</summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.Create(System.Object)">
            <summary>根据指定键值创建读写锁，一般读写锁需要针对指定资源唯一</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireRead">
            <summary>请求读取锁</summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireRead(System.Int32)">
            <summary>请求读取锁，等待指定时间</summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否取得锁</returns>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.ReleaseRead">
            <summary>释放读取锁</summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireWrite">
            <summary>请求写入锁</summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireWrite(System.Int32)">
            <summary>请求写入锁，等待指定时间</summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否取得锁</returns>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.ReleaseWrite">
            <summary>释放写入锁</summary>
        </member>
        <member name="P:NewLife.Threading.ReadWriteLock.Max">
            <summary>最大可独占资源数，默认1</summary>
        </member>
        <member name="P:NewLife.Threading.ReadWriteLock.ReadTimeout">
            <summary>读取锁等待超时时间，默认1秒</summary>
        </member>
        <member name="P:NewLife.Threading.ReadWriteLock.WriteTimeout">
            <summary>写入锁等待超时时间，默认5秒</summary>
        </member>
        <member name="T:NewLife.Reflection.AssemblyX">
            <summary>程序集辅助类。使用Create创建，保证每个程序集只有一个辅助类</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Create(System.Reflection.Assembly)">
            <summary>创建程序集辅助对象</summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetCustomAttribute``1">
            <summary>获取自定义属性</summary>
            <typeparam name="TAttribute"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetCustomAttributeValue``2">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String)">
            <summary>从程序集中查找指定名称的类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetTypeInternal(System.String)">
            <summary>在程序集中查找类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins``1">
            <summary>查找插件</summary>
            <typeparam name="TPlugin"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins(System.Type)">
            <summary>查找插件，带缓存</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type)">
            <summary>查找所有非系统程序集中的所有插件</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type,System.Boolean)">
            <summary>查找所有非系统程序集中的所有插件</summary>
            <remarks>继承类所在的程序集会引用baseType所在的程序集，利用这一点可以做一定程度的性能优化。</remarks>
            <param name="baseType"></param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type,System.Boolean,System.Boolean)">
            <summary>查找所有非系统程序集中的所有插件</summary>
            <remarks>继承类所在的程序集会引用baseType所在的程序集，利用这一点可以做一定程度的性能优化。</remarks>
            <param name="baseType"></param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <param name="excludeGlobalTypes">指示是否应检查来自所有引用程序集的类型。如果为 false，则检查来自所有引用程序集的类型。 否则，只检查来自非全局程序集缓存 (GAC) 引用的程序集的类型。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.IsReferencedFrom(System.Reflection.Assembly,System.String)">
            <summary><paramref name="asm"/> 是否引用了 <paramref name="baseAsmName"/></summary>
            <param name="asm">程序集</param>
            <param name="baseAsmName">被引用程序集全名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies(System.AppDomain)">
            <summary>获取指定程序域所有程序集</summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies">
            <summary>获取当前程序域所有程序集</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyGetAssemblies">
            <summary>获取当前程序域所有只反射程序集的辅助类</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoad(System.String)">
            <summary>只反射加载指定路径的所有程序集</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetMyAssemblies">
            <summary>获取当前应用程序的所有程序集，不包括系统程序集，仅限本目录</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Equal(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>判断两个程序集是否相同，避免引用加载和执行上下文加载的相同程序集显示不同</summary>
            <param name="asm1"></param>
            <param name="asm2"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Asm">
            <summary>程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Version">
            <summary>程序集版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Title">
            <summary>程序集标题</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.FileVersion">
            <summary>文件版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Compile">
            <summary>编译时间</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.CompileVersion">
            <summary>编译版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Company">
            <summary>公司名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Location">
            <summary>获取包含清单的已加载文件的路径或 UNC 位置。</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Types">
            <summary>类型集合，当前程序集的所有类型，包括私有和内嵌，非内嵌请直接调用Asm.GetTypes()</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.TypeXs">
            <summary>类型集合，当前程序集的所有类型</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.IsSystemAssembly">
            <summary>是否系统程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Entry">
            <summary>入口程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.AssemblyPaths">
            <summary>程序集目录集合</summary>
        </member>
        <member name="T:NewLife.Serialization.WriteObjectCallback">
            <summary>数据写入方法</summary>
            <param name="writer">写入器</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:NewLife.Serialization.IObjectMemberInfo">
            <summary>对象成员信息</summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.Item(System.Object)">
            <summary>对目标对象的该成员取值赋值</summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DuckTyping">
            <summary>鸭子类型。用于解决编写插件时必须实现插件接口的问题。使用适配器模式，动态生成代理类。</summary>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.Implement``1(System.Object[])">
            <summary>转换多个对象</summary>
            <typeparam name="TInterface"></typeparam>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.Implement``1(System.Object)">
            <summary>转换单个对象</summary>
            <typeparam name="TInterface"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.Implement(System.Object,System.Type)">
            <summary>转换单个对象</summary>
            <param name="obj"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.PrepareDuckTypes``1(System.Type[])">
            <summary>准备鸭子类型</summary>
            <typeparam name="TInterface"></typeparam>
            <param name="duckedTypes"></param>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.CreateDuckTypes(System.Type,System.Type[])">
            <summary>Core-Creation of the DuckTypes. It asumes that all arguments are validated before the method is called.</summary>
            <param name="interfaceType"></param>
            <param name="duckedTypes">a distinct list of Types to create the Duck-Types</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.WeakAction`1">
            <summary>弱引用Action</summary>
            <remarks>
            常见的事件和委托，都包括两部分：对象和方法，当然如果委托到静态方法上，对象是为空的。
            如果把事件委托到某个对象的方法上，同时就间接的引用了这个对象，导致其一直无法被回收，从而造成内存泄漏。
            弱引用Action，原理就是把委托拆分，然后弱引用对象部分，需要调用委托的时候，再把对象“拉”回来，如果被回收了，就没有必要再调用它的方法了。
            </remarks>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakAction`1.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Method">
            <summary>委托方法</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Handler">
            <summary>经过包装的新的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.UnHandler">
            <summary>取消注册的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Once">
            <summary>是否只使用一次，如果只使用一次，执行委托后马上取消注册</summary>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>实例化</summary>
            <param name="target"></param>
            <param name="method"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo,System.Action{System.Action{`0}},System.Boolean)">
            <summary>实例化</summary>
            <param name="target"></param>
            <param name="method"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate)">
            <summary>实例化</summary>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate,System.Action{System.Action{`0}},System.Boolean)">
            <summary>使用事件处理器、取消注册回调、是否一次性事件来初始化</summary>
            <param name="handler"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.Invoke(`0)">
            <summary>调用委托</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.op_Implicit(NewLife.WeakAction{`0})~System.Action{`0}">
            <summary>把弱引用事件处理器转换为普通事件处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakAction`1.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.WeakAction`1.IsAlive">
            <summary>是否可用</summary>
        </member>
        <member name="T:NewLife.Xml.XmlReaderWriterSettings">
            <summary>Xml序列化设置</summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderWriterSettings.#ctor">
            <summary>实例化Xml序列化设置</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderWriterSettings.MemberAsAttribute">
            <summary>成员作为属性</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderWriterSettings.IgnoreDefault">
            <summary>忽略默认</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderWriterSettings.DateTimeMode">
            <summary>指定日期时间输出成什么时间,本地还是UTC时间,默认是UTC时间</summary>
        </member>
        <member name="T:NewLife.Web.WebHelper">
            <summary>网页工具类</summary>
        </member>
        <member name="M:NewLife.Web.WebHelper.WriteScript(System.String)">
            <summary>输出脚本</summary>
            <param name="script"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.GetSubString(System.String,System.Int32,System.Int32)">
            <summary>按字节截取</summary>
            <param name="Str">字符串</param>
            <param name="StartIndex">开始位置</param>
            <param name="Len">长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.JsEncode(System.String)">
            <summary>Js脚本编码</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.Alert(System.String)">
            <summary>弹出页面提示</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndEnd(System.String)">
            <summary>弹出页面提示并停止输出后退一步！</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndRefresh(System.String)">
            <summary>弹出页面提示，并刷新该页面</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndRedirect(System.String,System.String)">
            <summary>弹出页面提示并重定向到另外的页面</summary>
            <param name="msg"></param>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndClose(System.String)">
            <summary>弹出页面提示并关闭当前页面</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.CheckEmptyAndFocus(System.Web.UI.Control,System.String)">
            <summary>检查控件值是否为空，若为空，显示错误信息，并聚焦到控件上</summary>
            <param name="control">要检查的控件</param>
            <param name="errmsg">错误信息。若为空，将使用ToolTip</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ExportExcel(System.Web.UI.WebControls.GridView,System.String,System.Int32)">
            <summary>导出Excel</summary>
            <param name="gv"></param>
            <param name="filename"></param>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.ExportExcel(System.Web.UI.WebControls.GridView,System.String,System.Int32,System.Text.Encoding)">
            <summary>导出Excel</summary>
            <param name="gv"></param>
            <param name="filename"></param>
            <param name="max"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestInt(System.String)">
            <summary>获取整型参数</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestBool(System.String)">
            <summary>接收布尔值</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestDateTime(System.String)">
            <summary>接收时间</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestDouble(System.String)">
            <summary>接收Double</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertInt(System.String)">
            <summary>字符转换为数字</summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertBool(System.String)">
            <summary>字符转换为布尔</summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertDateTime(System.String)">
            <summary>字符转换为时间</summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertDouble(System.String)">
            <summary>字符转换</summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.WebHelper.UserHost">
            <summary>用户主机</summary>
        </member>
        <member name="T:NewLife.Threading.ThreadPoolX">
            <summary>线程池。所有静态方法和实例方法均是线程安全。</summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.SynLock_mt">
            <summary>用于维护管理线程的锁</summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX._ManagerThread">
            <summary>使用volatile关键字，等到对象创建完成</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Init">
            <summary>第一个任务到来时初始化线程池</summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.SyncLock_Threads">
            <summary>用户维护线程组的锁</summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.Sync_Tasks">
            <summary>任务队列同步锁</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.#ctor(System.String)">
            <summary>构造一个线程池</summary>
            <param name="name">线程池名</param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Create(System.String)">
            <summary>创建线程池。一个名字只能创建一个线程池。线程安全。</summary>
            <param name="name">线程池名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback)">
            <summary>把用户工作项放入队列</summary>
            <param name="method">任务方法</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback,System.Object)">
            <summary>把用户工作项放入队列</summary>
            <param name="method">任务方法</param>
            <param name="argument">任务参数</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback,System.Threading.WaitCallback,System.Object)">
            <summary>把用户工作项放入队列。指定任务被取消时执行的方法，该方法仅针对尚未被线程开始调用时的任务有效</summary>
            <param name="method">任务方法</param>
            <param name="abortMethod">任务被取消时执行的方法</param>
            <param name="argument">任务参数</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(NewLife.Threading.ThreadTask)">
            <summary>把用户工作项放入队列</summary>
            <param name="task">任务</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Abort(System.Int32)">
            <summary>取消任务</summary>
            <param name="id">任务编号</param>
            <returns>任务状态</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAllTask">
            <summary>取消所有未开始任务</summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAllThread">
            <summary>取消所有进行中任务</summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAll">
            <summary>取消所有任务</summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Query(System.Int32)">
            <summary>查询任务状态</summary>
            <param name="id">任务编号</param>
            <returns>任务状态</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueryCount">
            <summary>查询任务个数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.WaitAll(System.Int32)">
            <summary>等待所有任务完成，并指定是否在等待之前退出同步域。</summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否在等待之前退出同步域</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Work">
            <summary>调度包装</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AddThread">
            <summary>添加线程。本方法不是线程安全，调用者需要自己维护线程安全</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Open">
            <summary>借用线程</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Close(NewLife.Threading.ThreadX)">
            <summary>归还线程</summary>
            <param name="thread"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(System.Threading.WaitCallback)">
            <summary>带异常处理的线程池任务调度</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>带异常处理的线程池任务调度</summary>
            <param name="callback"></param>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(System.Threading.WaitCallback,System.Object,System.Action{System.Exception})">
            <summary>带异常处理的线程池任务调度，即使不指定异常处理方法，也不允许异常抛出，以免造成应用程序退出</summary>
            <param name="callback"></param>
            <param name="state"></param>
            <param name="errCallback">发生异常时调用的方法</param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(NewLife.Reflection.Func)">
            <summary>带异常处理的线程池任务调度</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(NewLife.Reflection.Func,System.Action{System.Exception})">
            <summary>带异常处理的线程池任务调度，即使不指定异常处理方法，也不允许异常抛出，以免造成应用程序退出</summary>
            <param name="callback"></param>
            <param name="errCallback">发生异常时调用的方法</param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Finalize">
            <summary>析构</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.MaxThreads">
            <summary>最大线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.MinThreads">
            <summary>最小线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Name">
            <summary>线程池名称</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.LastError">
            <summary>最后的异常</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.ManagerThread">
            <summary>维护线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Threads">
            <summary>线程组。适用该资源时，记得加上线程锁lockObj</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.ThreadCount">
            <summary>当前线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.RunningCount">
            <summary>正在处理任务的线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Event">
            <summary>事件量</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Tasks">
            <summary>任务队列</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Instance">
            <summary>默认线程池</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="T:NewLife.Reflection.Func">
            <summary>没有参数和返回值的委托</summary>
        </member>
        <member name="T:NewLife.Reflection.Func`1">
            <summary>具有指定类型返回的委托</summary>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`2">
            <summary>具有指定参数和返回的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`3">
            <summary>具有指定两个参数和返回的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`4">
            <summary>具有指定三个参数和返回的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`5">
            <summary>具有指定四个参数和返回的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`6">
            <summary>具有指定五个参数和返回的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="arg5"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonAtomStringReader">
             <summary>Json 原子元素读取器</summary>
             <remarks>
             原子元素是指在Json中不可嵌套的元素,包括
               基础类型: 数字(整型,浮点型) 字符串 null true/false
               复合类型起始符号: {} []
               分割符号: , :
               结束符
               非法符号:无法识别的字面值
            
             这个类不检查Json复合格式是否有误,所以可以用来解析类似Json格式的字符串
             </remarks>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomStringReader.NUMBER_TYPES">
            <summary>所有的数字类型,包括整数和浮点数</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomStringReader.INTEGER_TYPES">
            <summary>所有的整数类型</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.#ctor(System.IO.TextReader)">
            <summary>构造方法</summary>
            <param name="reader"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.Read(System.Boolean,System.String@)">
            <summary>读取下一个原子元素,返回原子元素的类型,输出参数str表示读到的字符串</summary>
            <remarks>
            一般情况下isDetect可以为false,如果需要探测下一个可读元素,则需要给isDetect参数为true
            </remarks>
            <param name="isDetect">为true表示探测,探测将只会读取一个字符,但不会移动流位置,直接重复探测将始终返回一样的结果</param>
            <param name="str">读取到的原始字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.MoveNext">
            <summary>将当前输入流位置向后移动一个字符,并返回读取到的字符</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.ReadString(System.Char,System.String@)">
            <summary>读取字符串,流位置以处于"之后,读到的字符串不包含结尾的",但流会被移动到"之后</summary>
            <param name="quotesChar"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.ReadEscapeChar">
            <summary>读取下一个转义字符,流已处于转义符\之后</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.ReadLiteral(System.Boolean,System.String@)">
             <summary>
             读取下一个字面值,可能是true false null 数字 无法识别
            
             isDetect为true时将不确保实际结果是返回的类型,因为仅仅预读一个字符无法确定上述字面值
             </summary>
             <param name="isDetect">为true表示探测,探测将只会读取一个字符,但不会移动流位置</param>
             <param name="str"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.Skip">
            <summary>跳过下一个读到的值,包括复合格式{...} [...]</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.Skip(System.Int32)">
             <summary>跳过接下来读到的值,可指定要跳过的复合对象深度</summary>
             <remarks>
             复合对象深度值是指当流位置和目标处于以下位置时
            
               [[1,2/*当前流位置*/,3]]/*跳到的目标*/
            
             调用Skip(1)将会将当前流位置移动到目标位置
             </remarks>
             <param name="initDepth">复合对象深度值,为0时表示不跳过复合对象,小于0时不做任何操作</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonAtomStringReader.TryDecodeUnicode(System.String,System.Char@)">
            <summary>尝试解码指定4个16进制字符表示的Unicode字符</summary>
            <param name="str"></param>
            <param name="cc"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.JsonAtomStringReader.Line">
            <summary>当前读取到的行号,从1开始</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonAtomStringReader.Column">
            <summary>当前读取到的列号,从1开始</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonAtomStringReader.SingleQuotesString">
            <summary>是否允许单引号字符串,单引号字符串不符合JSON标准,默认false</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonAtomType">
            <summary>原子元素类型</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.NONE">
            <summary>无 一般表示结尾</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.BRACE_OPEN">
            <summary>大括号开始 {</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.BRACE_CLOSE">
            <summary>大括号结束 }</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.BRACKET_OPEN">
            <summary>方括号开始 [</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.BRACKET_CLOSE">
            <summary>方括号结束 ]</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.COLON">
            <summary>冒号 :</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.COMMA">
            <summary>逗号 ,</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.STRING">
            <summary>字符串 "包含的</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.LITERAL">
            <summary>字面值 无法识别的字面值</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.TRUE">
            <summary>字面值 true</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.FALSE">
            <summary>字面值 false</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.NULL">
            <summary>字面值 null</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.NUMBER">
            <summary>字面值 数字,非科学计数法表示的</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.NUMBER_EXP">
            <summary>字面值 数字,科学计数发表示的</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.FLOAT">
            <summary>字面值 浮点数,非科学计数法表示的浮点数</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonAtomType.FLOAT_EXP">
            <summary>字面值 浮点数,科学计数法表示的浮点数</summary>
        </member>
        <member name="T:NewLife.Serialization.BinarySettings">
            <summary>二进制序列化设置</summary>
        </member>
        <member name="M:NewLife.Serialization.BinarySettings.#ctor">
            <summary>实例化二进制序列化设置</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.IsLittleEndian">
            <summary>是否小端字节序。x86系列则采用Little-Endian方式存储数据；网络协议都是Big-Endian；</summary>
            <remarks>
            网络协议都是Big-Endian；
            Java编译的都是Big-Endian；
            Motorola的PowerPC是Big-Endian；
            x86系列则采用Little-Endian方式存储数据；
            ARM同时支持 big和little，实际应用中通常使用Little-Endian。
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.EncodeInt">
            <summary>编码整数。打开后将使用7位编码写入所有16、32和64位整数，节省空间。打开后字节序设置将会无效。默认关闭。</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.IgnoreType">
            <summary>忽略类型。打开后将不输出对象类型，按照读取时指定的类型读取。默认打开。</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.IgnoreName">
            <summary>忽略名称。打开后将不输出成员名称，按照读取时指定的类型读取。默认打开。</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.SplitComplexType">
            <summary>是否拆分复杂类型。将拆分数组、内嵌和泛型</summary>
        </member>
        <member name="T:NewLife.Serialization.BinarySettings.TypeKinds">
            <summary>类型样式</summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Normal">
            <summary>普通类型</summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Array">
            <summary>数组类型</summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Nested">
            <summary>内嵌类型</summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Generic">
            <summary>泛型类型</summary>
        </member>
        <member name="T:NewLife.Security.Crc16">
            <summary>CRC16校验</summary>
        </member>
        <member name="F:NewLife.Security.Crc16.CrcTable">
            <summary>CRC16表</summary>
        </member>
        <member name="F:NewLife.Security.Crc16.crc">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Int16)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验</summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验</summary>
            <param name="stream"></param>
            <param name="count"></param>
        </member>
        <member name="P:NewLife.Security.Crc16.Value">
            <summary>校验值</summary>
        </member>
        <member name="T:NewLife.Security.Certificate">
            <summary>证书</summary>
            <remarks>http://blogs.msdn.com/b/dcook/archive/2008/11/25/creating-a-self-signed-certificate-in-c.aspx</remarks>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.String)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="insecurePassword"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>建立自签名证书</summary>
            <param name="x500">例如CN=SelfSignCertificate;C=China;OU=NewLife;O=Development Team;E=nnhy@vip.qq.com，其中CN是显示名</param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>建立自签名证书</summary>
            <param name="distName"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.TraceStream">
            <summary>跟踪流。包装一个基础数据流，主要用于重写Read/Write等行为，跟踪程序操作数据流的过程</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>写入</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.WriteByte(System.Byte)">
            <summary>写入一个字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>读取</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.ReadByte">
            <summary>读取一个字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>异步开始读</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>异步开始写</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.EndRead(System.IAsyncResult)">
            <summary>异步读结束</summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.EndWrite(System.IAsyncResult)">
            <summary>异步写结束</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>设置流位置</summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.Close">
            <summary>关闭数据流</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Flush">
            <summary>刷新缓冲区</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.SetLength(System.Int64)">
            <summary>设置长度</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor">
            <summary>实例化跟踪流</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor(System.IO.Stream)">
            <summary>实例化跟踪流</summary>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.Log.TraceStream.BaseStream">
            <summary>基础流</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.TraceMembers">
            <summary>跟踪的成员</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.IsLittleEndian">
            <summary>是否小端字节序。x86系列则采用Little-Endian方式存储数据；网络协议都是Big-Endian；</summary>
            <remarks>
            网络协议都是Big-Endian；
            Java编译的都是Big-Endian；
            Motorola的PowerPC是Big-Endian；
            x86系列则采用Little-Endian方式存储数据；
            ARM同时支持 big和little，实际应用中通常使用Little-Endian。
            </remarks>
        </member>
        <member name="P:NewLife.Log.TraceStream.ShowPositionStep">
            <summary>显示位置的步长，位移超过此长度后输出位置。默认10，设为0不输出位置</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanRead">
            <summary>可读</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanSeek">
            <summary>可搜索</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanTimeout">
            <summary>可超时</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanWrite">
            <summary>可写</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.ReadTimeout">
            <summary>可读</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.WriteTimeout">
            <summary>读写超时</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Position">
            <summary>位置</summary>
        </member>
        <member name="E:NewLife.Log.TraceStream.OnAction">
            <summary>操作时触发</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.UseConsole">
            <summary>是否使用控制台</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Encoding">
            <summary>编码</summary>
        </member>
        <member name="T:System.StringHelper">
            <summary>字符串助手类</summary>
        </member>
        <member name="M:System.StringHelper.EqualIgnoreCase(System.String,System.String)">
            <summary>忽略大小写的字符串比较</summary>
            <param name="value"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.IsNullOrWhiteSpace(System.String)">
            <summary>是否空或者空白字符串</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Split(System.String,System.String[])">
            <summary>拆分字符串</summary>
            <param name="value"></param>
            <param name="separators"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.SplitAsDictionary(System.String,System.String,System.String[])">
            <summary>拆分字符串成为名值字典</summary>
            <param name="str"></param>
            <param name="nameValueSeparator"></param>
            <param name="separators"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LevenshteinSearch(System.String,System.String[])">
            <summary>编辑距离搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key">关键字</param>
            <param name="words">词组</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LevenshteinDistance(System.String,System.String)">
            <summary>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="str1"></param>
            <param name="str2"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LCSSearch(System.String,System.String[])">
            <summary>最长公共子序列搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key"></param>
            <param name="words"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LCSDistance(System.String,System.String[])">
            <summary>
            最长公共子序列问题是寻找两个或多个已知数列最长的子序列。
            一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。
            The longest common subsequence (LCS) problem is to find the longest subsequence common to all sequences in a set of sequences (often just two). Note that subsequence is different from a substring, see substring vs. subsequence. It is a classic computer science problem, the basis of diff (a file comparison program that outputs the differences between two files), and has applications in bioinformatics.
            </summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="word"></param>
            <param name="keys">多个关键字。长度必须大于0，必须按照字符串长度升序排列。</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.HttpMessageProviderHandler">
            <summary>Http消息提供者处理器。为消息提供者提供承载，核心是调用<see cref="M:HttpServerMessageProvider.Instance.Process"/></summary>
        </member>
        <member name="M:NewLife.Messaging.HttpMessageProviderHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>处理。</summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Messaging.HttpMessageProviderHandler.IsReusable">
            <summary>是否可重用。</summary>
        </member>
        <member name="T:NewLife.Messaging.HttpServerMessageProvider">
            <summary>Http服务器消息提供者。单例模式，通过静态属性<see cref="P:NewLife.Messaging.HttpServerMessageProvider.Instance"/>访问单一实例。</summary>
            <remarks>不支持<see cref="M:SendAnReceive"/>方法</remarks>
        </member>
        <member name="M:NewLife.Messaging.HttpServerMessageProvider.OnSend(System.IO.Stream)">
            <summary>发送数据流。</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.HttpServerMessageProvider.SendAndReceive(NewLife.Messaging.Message,System.Int32)">
            <summary>已重载。不支持。</summary>
            <param name="message"></param>
            <param name="millisecondsTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.HttpServerMessageProvider.Process">
            <summary>处理。</summary>
        </member>
        <member name="P:NewLife.Messaging.HttpServerMessageProvider.Context">
            <summary>上下文</summary>
        </member>
        <member name="P:NewLife.Messaging.HttpServerMessageProvider.Instance">
            <summary>静态实例</summary>
        </member>
        <member name="T:NewLife.Messaging.CompressionMessage">
            <summary>经过压缩的消息</summary>
            <remarks>因为写入一个字节的对象引用，所以<see cref="P:NewLife.Messaging.CompressionMessage.Message"/>为空时后面不怕有其它包</remarks>
        </member>
        <member name="M:NewLife.Messaging.CompressionMessage.OnWrite(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>已重载。</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="M:NewLife.Messaging.CompressionMessage.OnRead(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>已重载。</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="M:NewLife.Messaging.CompressionMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.CompressionMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.CompressionMessage.Message">
            <summary>内部消息对象</summary>
        </member>
        <member name="T:NewLife.Web.HttpStream">
            <summary>HTTP输入输出流</summary>
        </member>
        <member name="M:NewLife.Web.HttpStream.#ctor(System.Web.HttpContext)">
            <summary>初始化</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.HttpStream.Flush">
            <summary>已重载。</summary>
        </member>
        <member name="P:NewLife.Web.HttpStream.Context">
            <summary>HTTP上下文</summary>
        </member>
        <member name="P:NewLife.Web.HttpStream.RemoteEndPoint">
            <summary>远程地址</summary>
        </member>
        <member name="T:NewLife.Common.HardInfo">
            <summary>硬件信息</summary>
        </member>
        <member name="M:NewLife.Common.HardInfo.ToExtend">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.HardInfo.FromExtend(NewLife.Xml.ExtendData)">
            <summary></summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.HardInfo.ToXml">
            <summary>导出XML</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.HardInfo.FromXml(System.String)">
            <summary>导入</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Common.HardInfo.MachineName">
            <summary>机器名</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.BaseBoard">
            <summary>主板</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Processors">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Disk">
            <summary>磁盘</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.DiskSerial">
            <summary>磁盘序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Volume">
            <summary>驱动器序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Macs">
            <summary>网卡</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.IPs">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.OSVersion">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Memory">
            <summary>内存</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.ScreenWidth">
            <summary>屏幕宽</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.ScreenHeight">
            <summary>屏幕高</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.DiskSize">
            <summary>磁盘大小</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Current">
            <summary>当前机器硬件信息</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.BaseBoard">
            <summary>主板序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Processors">
            <summary>处理器序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Memory">
            <summary>内存总量</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Disk">
            <summary>磁盘名称</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.DiskSerial">
            <summary>磁盘序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Volume">
            <summary>驱动器序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Macs">
            <summary>网卡地址序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.IPs">
            <summary>IP地址</summary>
        </member>
        <member name="T:NewLife.Reflection.PropertyInfoX">
            <summary>快速属性访问</summary>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.Create(System.Reflection.PropertyInfo)">
            <summary>创建</summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.Create(System.Type,System.String)">
            <summary>创建</summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue(System.Object)">
            <summary>取值</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Object,System.Object)">
            <summary>赋值</summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue(System.Type,System.Object,System.String)">
            <summary>快速获取静态属性。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <param name="type"></param>
            <param name="target"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Type,System.Object,System.String,System.Object)">
            <summary>静态快速赋值。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <param name="type"></param>
            <param name="target"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue(System.Type,System.String)">
            <summary>快速获取静态属性。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Type,System.String,System.Object)">
            <summary>静态属性快速赋值。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue``1(System.Object,System.String)">
            <summary>静态快速取值。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue``2(System.String)">
            <summary>快速获取静态属性。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Object,System.String,System.Object)">
            <summary>成员属性快速赋值。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <param name="target"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue``1(System.String,System.Object)">
            <summary>快速设置静态属性。若属性不存在，会抛出异常。不确定属性是否存在时，建议使用Create方法</summary>
            <typeparam name="TTarget"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.op_Implicit(NewLife.Reflection.PropertyInfoX)~System.Reflection.PropertyInfo">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.op_Implicit(System.Reflection.PropertyInfo)~NewLife.Reflection.PropertyInfoX">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.Property">
            <summary>目标属性</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.GetMethod">
            <summary>读取方法</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.SetMethod">
            <summary>设置方法</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.GetHandler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.SetHandler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="T:NewLife.Reflection.IIndexAccessor">
            <summary>
            索引器接访问口。
            该接口用于通过名称快速访问对象属性或字段（属性优先）。
            </summary>
        </member>
        <member name="P:NewLife.Reflection.IIndexAccessor.Item(System.String)">
            <summary>获取/设置 指定名称的属性或字段的值</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.TypeX">
            <summary>类型辅助类</summary>
        </member>
        <member name="M:NewLife.Reflection.TypeX.Create(System.Type)">
            <summary>创建类型辅助对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.CreateInstance(System.Object[])">
            <summary>创建实例</summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.CreateInstance(System.Type,System.Object[])">
            <summary>快速反射创建指定类型的实例</summary>
            <param name="type"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.CreateInstance``1(System.Object[])">
            <summary>快速反射创建指定类型的实例</summary>
            <typeparam name="T"></typeparam>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetValue(System.Object)">
            <summary>取值，返回自己</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.IsPlugin(System.Type)">
            <summary>是否指定类型的插件</summary>
            <param name="type">指定类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetType(System.String)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法。</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramTypes"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetMethod(System.String,System.Type[])">
            <summary>获取方法。</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="name"></param>
            <param name="paramTypes"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.Equal(System.Type,System.Type)">
            <summary>判断两个类型是否相同，避免引用加载和执行上下文加载的相同类型显示不同</summary>
            <param name="type1"></param>
            <param name="type2"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value"></param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.ChangeType``1(System.Object)">
            <summary>类型转换</summary>
            <typeparam name="TResult"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.IsNullable(System.Type)">
            <summary>判断某个类型是否可空类型</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetTypeArray(System.Object[])">
            <summary>从参数数组中获取类型数组</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetElementType">
            <summary>获取元素类型</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.op_Implicit(NewLife.Reflection.TypeX)~System.Type">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.op_Implicit(System.Type)~NewLife.Reflection.TypeX">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.IsSubclassOf(System.Type)">
            <summary>确定当前 <see cref="T:System.Type" /> 表示的类是否是从指定的 <see cref="T:System.Type" /> 表示的类派生的。</summary>
            <returns>如果 Type 由 <paramref name="c" /> 参数表示并且当前的 Type 表示类，并且当前的 Type 所表示的类是从 <paramref name="c" /> 所表示的类派生的，则为 true；否则为 false。如果 <paramref name="c" /> 和当前的 Type 表示相同的类，则此方法还返回 false。</returns>
            <param name="c">与当前的 Type 进行比较的 Type。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 参数为 null。</exception>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Handler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Name">
            <summary>类型名称。主要处理泛型</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.FullName">
            <summary>完整类型名称。包含命名空间，但是不包含程序集信息</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.IsSystemType">
            <summary>是否系统类型</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Binder">
            <summary>专用绑定器</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Properties">
            <summary>属性集合</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.BaseType">
            <summary>基类。因计算类型基类极慢，故缓存</summary>
            <remarks><see cref="P:Type.BaseType"/>实在太慢了</remarks>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Code">
            <summary>基础类型代码</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.IsEnum">
            <summary>获取一个值，该值指示当前的 <see cref="T:System.Type" /> 是否表示枚举。</summary>
            <returns>如果当前 <see cref="T:System.Type" /> 表示枚举，则为 true；否则为 false。</returns>
        </member>
        <member name="P:NewLife.Reflection.TypeX.IsInt">
            <summary>是否整型。从Int16到UInt64共六种</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.IsValueType">
            <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为值类型。</summary>
            <returns>如果 <see cref="T:System.Type" /> 是值类型，则为 true；否则为 false。</returns>
        </member>
        <member name="T:NewLife.Reflection.TypeX._">
            <summary>常用类型</summary>
        </member>
        <member name="F:NewLife.Reflection.TypeX._.Type">
            <summary>类型</summary>
        </member>
        <member name="F:NewLife.Reflection.TypeX._.ValueType">
            <summary>值类型</summary>
        </member>
        <member name="F:NewLife.Reflection.TypeX._.Enum">
            <summary>枚举类型</summary>
        </member>
        <member name="F:NewLife.Reflection.TypeX._.Object">
            <summary>对象类型</summary>
        </member>
        <member name="F:NewLife.Reflection.TypeX._.String">
            <summary>字符串类型</summary>
        </member>
        <member name="T:NewLife.Reflection.EventInfoX">
            <summary>事件扩展</summary>
        </member>
        <member name="M:NewLife.Reflection.EventInfoX.Create(System.Reflection.EventInfo)">
            <summary>创建</summary>
            <param name="ev"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.EventInfoX.Event">
            <summary>事件</summary>
        </member>
        <member name="T:NewLife.Linq.Enumerable">
            <summary>提供一组用于查询实现 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的对象的 static（在 Visual Basic 中为 Shared）方法。</summary>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>基于谓词筛选值序列。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中满足条件的元素。</returns>
            <param name="source">要筛选的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32,System.Boolean})">
            <summary>基于谓词筛选值序列。将在谓词函数的逻辑中使用每个元素的索引。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中满足条件的元素。</returns>
            <param name="source">要筛选的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个源元素是否满足条件的函数；该函数的第二个参数表示源元素的索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>将序列中的每个元素投影到新表中。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素为对 <paramref name="source" /> 的每个元素调用转换函数的结果。</returns>
            <param name="source">一个值序列，要对该序列调用转换函数。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="selector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32,``1})">
            <summary>通过合并元素的索引将序列的每个元素投影到新表中。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素为对 <paramref name="source" /> 的每个元素调用转换函数的结果。</returns>
            <param name="source">一个值序列，要对该序列调用转换函数。</param>
            <param name="selector">一个应用于每个源元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="selector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>将序列的每个元素投影到 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 并将结果序列合并为一个序列。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素是对输入序列的每个元素调用一对多转换函数的结果。</returns>
            <param name="source">一个要投影的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="selector" /> 返回的序列元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>将序列的每个元素投影到 <see cref="T:System.Collections.Generic.IEnumerable`1" />，并将结果序列合并为一个序列。每个源元素的索引用于该元素的投影表。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素是对输入序列的每个元素调用一对多转换函数的结果。</returns>
            <param name="source">一个要投影的值序列。</param>
            <param name="selector">一个应用于每个源元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="selector" /> 返回的序列元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},NewLife.Reflection.Func{``0,``1,``2})">
            <summary>将序列的每个元素投影到 <see cref="T:System.Collections.Generic.IEnumerable`1" />，并将结果序列合并为一个序列，并对其中每个元素调用结果选择器函数。每个源元素的索引用于该元素的中间投影表。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素是对 <paramref name="source" /> 的每个元素调用一对多转换函数 <paramref name="collectionSelector" />，然后将那些序列元素中的每一个及其相应的源元素映射为结果元素的结果。</returns>
            <param name="source">一个要投影的值序列。</param>
            <param name="collectionSelector">一个应用于每个源元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <param name="resultSelector">一个应用于中间序列的每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TCollection">
              <paramref name="collectionSelector" /> 收集的中间元素的类型。</typeparam>
            <typeparam name="TResult">结果序列的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="collectionSelector" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Collections.Generic.IEnumerable{``1}},NewLife.Reflection.Func{``0,``1,``2})">
            <summary>将序列的每个元素投影到 <see cref="T:System.Collections.Generic.IEnumerable`1" />，并将结果序列合并为一个序列，并对其中每个元素调用结果选择器函数。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素是对 <paramref name="source" /> 的每个元素调用一对多转换函数 <paramref name="collectionSelector" />，然后将那些序列元素中的每一个及其相应的源元素映射为结果元素的结果。</returns>
            <param name="source">一个要投影的值序列。</param>
            <param name="collectionSelector">一个应用于输入序列的每个元素的转换函数。</param>
            <param name="resultSelector">一个应用于中间序列的每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TCollection">
              <paramref name="collectionSelector" /> 收集的中间元素的类型。</typeparam>
            <typeparam name="TResult">结果序列的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="collectionSelector" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>从序列的开头返回指定数量的连续元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列开头的指定数量的元素。</returns>
            <param name="source">要从其返回元素的序列。</param>
            <param name="count">要返回的元素数量。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>只要满足指定的条件，就会返回序列的元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中出现在测试不再能够通过的元素之前的元素。</returns>
            <param name="source">要从其返回元素的序列。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32,System.Boolean})">
            <summary>只要满足指定的条件，就会返回序列的元素。将在谓词函数的逻辑中使用元素的索引。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中出现在测试不再能够通过的元素之前的元素。</returns>
            <param name="source">要从其返回元素的序列。</param>
            <param name="predicate">用于测试每个源元素是否满足条件的函数；该函数的第二个参数表示源元素的索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>跳过序列中指定数量的元素，然后返回剩余的元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中指定索引后出现的元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="count">返回剩余元素前要跳过的元素数量。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>只要满足指定的条件，就跳过序列中的元素，然后返回剩余元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中的元素，该输入序列从线性系列中没有通过 <paramref name="predicate" /> 指定测试的第一个元素开始。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32,System.Boolean})">
            <summary>只要满足指定的条件，就跳过序列中的元素，然后返回剩余元素。将在谓词函数的逻辑中使用元素的索引。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含输入序列中的元素，该输入序列从线性系列中没有通过 <paramref name="predicate" /> 指定测试的第一个元素开始。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个源元素是否满足条件的函数；该函数的第二个参数表示源元素的索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NewLife.Reflection.Func{``0,``2},NewLife.Reflection.Func{``1,``2},NewLife.Reflection.Func{``0,``1,``3})">
            <summary>基于匹配键对两个序列的元素进行关联。使用默认的相等比较器对键进行比较。</summary>
            <returns>一个具有 <paramref name="TResult" /> 类型元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，这些元素是通过对两个序列执行内部联接得来的。</returns>
            <param name="outer">要联接的第一个序列。</param>
            <param name="inner">要与第一个序列联接的序列。</param>
            <param name="outerKeySelector">用于从第一个序列的每个元素提取联接键的函数。</param>
            <param name="innerKeySelector">用于从第二个序列的每个元素提取联接键的函数。</param>
            <param name="resultSelector">用于从两个匹配元素创建结果元素的函数。</param>
            <typeparam name="TOuter">第一个序列中的元素的类型。</typeparam>
            <typeparam name="TInner">第二个序列中的元素的类型。</typeparam>
            <typeparam name="TKey">键选择器函数返回的键的类型。</typeparam>
            <typeparam name="TResult">结果元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="outer" /> 或 <paramref name="inner" /> 或 <paramref name="outerKeySelector" /> 或 <paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NewLife.Reflection.Func{``0,``2},NewLife.Reflection.Func{``1,``2},NewLife.Reflection.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>基于匹配键对两个序列的元素进行关联。使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对键进行比较。</summary>
            <returns>一个具有 <paramref name="TResult" /> 类型元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，这些元素是通过对两个序列执行内部联接得来的。</returns>
            <param name="outer">要联接的第一个序列。</param>
            <param name="inner">要与第一个序列联接的序列。</param>
            <param name="outerKeySelector">用于从第一个序列的每个元素提取联接键的函数。</param>
            <param name="innerKeySelector">用于从第二个序列的每个元素提取联接键的函数。</param>
            <param name="resultSelector">用于从两个匹配元素创建结果元素的函数。</param>
            <param name="comparer">一个 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />，用于对键进行哈希处理和比较。</param>
            <typeparam name="TOuter">第一个序列中的元素的类型。</typeparam>
            <typeparam name="TInner">第二个序列中的元素的类型。</typeparam>
            <typeparam name="TKey">键选择器函数返回的键的类型。</typeparam>
            <typeparam name="TResult">结果元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="outer" /> 或 <paramref name="inner" /> 或 <paramref name="outerKeySelector" /> 或 <paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NewLife.Reflection.Func{``0,``2},NewLife.Reflection.Func{``1,``2},NewLife.Reflection.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>基于键相等对两个序列的元素进行关联并对结果进行分组。使用默认的相等比较器对键进行比较。</summary>
            <returns>一个包含 <paramref name="TResult" /> 类型的元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，这些元素可通过对两个序列执行分组联接获取。</returns>
            <param name="outer">要联接的第一个序列。</param>
            <param name="inner">要与第一个序列联接的序列。</param>
            <param name="outerKeySelector">用于从第一个序列的每个元素提取联接键的函数。</param>
            <param name="innerKeySelector">用于从第二个序列的每个元素提取联接键的函数。</param>
            <param name="resultSelector">用于从第一个序列的元素和第二个序列的匹配元素集合中创建结果元素的函数。</param>
            <typeparam name="TOuter">第一个序列中的元素的类型。</typeparam>
            <typeparam name="TInner">第二个序列中的元素的类型。</typeparam>
            <typeparam name="TKey">键选择器函数返回的键的类型。</typeparam>
            <typeparam name="TResult">结果元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="outer" /> 或 <paramref name="inner" /> 或 <paramref name="outerKeySelector" /> 或 <paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NewLife.Reflection.Func{``0,``2},NewLife.Reflection.Func{``1,``2},NewLife.Reflection.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>基于键相等对两个序列的元素进行关联并对结果进行分组。使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对键进行比较。</summary>
            <returns>一个包含 <paramref name="TResult" /> 类型的元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，这些元素可通过对两个序列执行分组联接获取。</returns>
            <param name="outer">要联接的第一个序列。</param>
            <param name="inner">要与第一个序列联接的序列。</param>
            <param name="outerKeySelector">用于从第一个序列的每个元素提取联接键的函数。</param>
            <param name="innerKeySelector">用于从第二个序列的每个元素提取联接键的函数。</param>
            <param name="resultSelector">用于从第一个序列的元素和第二个序列的匹配元素集合中创建结果元素的函数。</param>
            <param name="comparer">一个 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />，用于对键进行哈希处理和比较。</param>
            <typeparam name="TOuter">第一个序列中的元素的类型。</typeparam>
            <typeparam name="TInner">第二个序列中的元素的类型。</typeparam>
            <typeparam name="TKey">键选择器函数返回的键的类型。</typeparam>
            <typeparam name="TResult">结果元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="outer" /> 或 <paramref name="inner" /> 或 <paramref name="outerKeySelector" /> 或 <paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据键按升序对序列的元素排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，其元素按键排序。</returns>
            <param name="source">一个要排序的值序列。</param>
            <param name="keySelector">用于从元素中提取键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>使用指定的比较器按升序对序列的元素排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，其元素按键排序。</returns>
            <param name="source">一个要排序的值序列。</param>
            <param name="keySelector">用于从元素中提取键的函数。</param>
            <param name="comparer">一个用于比较键的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据键按降序对序列的元素排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，将根据键按降序对其元素进行排序。</returns>
            <param name="source">一个要排序的值序列。</param>
            <param name="keySelector">用于从元素中提取键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>使用指定的比较器按降序对序列的元素排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，将根据键按降序对其元素进行排序。</returns>
            <param name="source">一个要排序的值序列。</param>
            <param name="keySelector">用于从元素中提取键的函数。</param>
            <param name="comparer">一个用于比较键的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ThenBy``2(NewLife.Linq.IOrderedEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据某个键按升序对序列中的元素执行后续排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，其元素按键排序。</returns>
            <param name="source">一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，包含要排序的元素。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ThenBy``2(NewLife.Linq.IOrderedEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>使用指定的比较器按升序对序列中的元素执行后续排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，其元素按键排序。</returns>
            <param name="source">一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，包含要排序的元素。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="comparer">一个用于比较键的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ThenByDescending``2(NewLife.Linq.IOrderedEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据某个键按降序对序列中的元素执行后续排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，将根据键按降序对其元素进行排序。</returns>
            <param name="source">一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，包含要排序的元素。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ThenByDescending``2(NewLife.Linq.IOrderedEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>使用指定的比较器按降序对序列中的元素执行后续排序。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，将根据键按降序对其元素进行排序。</returns>
            <param name="source">一个 <see cref="T:NewLife.Linq.IOrderedEnumerable`1" />，包含要排序的元素。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="comparer">一个用于比较键的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组。</summary>
            <returns>在 C# 中为 IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;，或者在 Visual Basic 中为 IEnumerable(Of IGrouping(Of TKey, TSource))，其中每个 <see cref="T:NewLife.Linq.IGrouping`2" /> 对象都包含一个对象序列和一个键。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组，并使用指定的比较器对键进行比较。</summary>
            <returns>在 C# 中为 IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;，或者在 Visual Basic 中为 IEnumerable(Of IGrouping(Of TKey, TSource))，其中每个 <see cref="T:NewLife.Linq.IGrouping`2" /> 对象都包含一个对象集合和一个键。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组，并且通过使用指定的函数对每个组中的元素进行投影。</summary>
            <returns>在 C# 中为 IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;，或者在 Visual Basic 中为 IEnumerable(Of IGrouping(Of TKey, TElement))，其中每个 <see cref="T:NewLife.Linq.IGrouping`2" /> 对象都包含一个类型为 <paramref name="TElement" /> 的对象集合和一个键。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="elementSelector">用于将每个源元素映射到 <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">
              <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据键选择器函数对序列中的元素进行分组。通过使用比较器对键进行比较，并且通过使用指定的函数对每个组的元素进行投影。</summary>
            <returns>在 C# 中为 IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;，或者在 Visual Basic 中为 IEnumerable(Of IGrouping(Of TKey, TElement))，其中每个 <see cref="T:NewLife.Linq.IGrouping`2" /> 对象都包含一个类型为 <paramref name="TElement" /> 的对象集合和一个键。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="elementSelector">用于将每个源元素映射到 <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">
              <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组，并且从每个组及其键中创建结果值。</summary>
            <returns>
              <paramref name="TResult" /> 类型的元素的集合，其中每个元素都表示对一个组及其键的投影。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="resultSelector">用于从每个组中创建结果值的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="resultSelector" /> 返回的结果值的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2},NewLife.Reflection.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组，并且从每个组及其键中创建结果值。通过使用指定的函数对每个组的元素进行投影。</summary>
            <returns>
              <paramref name="TResult" /> 类型的元素的集合，其中每个元素都表示对一个组及其键的投影。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="elementSelector">用于将每个源元素映射到 <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的函数。</param>
            <param name="resultSelector">用于从每个组中创建结果值的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">每个 <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="resultSelector" /> 返回的结果值的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组，并且从每个组及其键中创建结果值。通过使用指定的比较器对键进行比较。</summary>
            <returns>
              <paramref name="TResult" /> 类型的元素的集合，其中每个元素都表示对一个组及其键的投影。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="resultSelector">用于从每个组中创建结果值的函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="resultSelector" /> 返回的结果值的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2},NewLife.Reflection.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数对序列中的元素进行分组，并且从每个组及其键中创建结果值。通过使用指定的比较器对键值进行比较，并且通过使用指定的函数对每个组的元素进行投影。</summary>
            <returns>
              <paramref name="TResult" /> 类型的元素的集合，其中每个元素都表示对一个组及其键的投影。</returns>
            <param name="source">要对其元素进行分组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于提取每个元素的键的函数。</param>
            <param name="elementSelector">用于将每个源元素映射到 <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的函数。</param>
            <param name="resultSelector">用于从每个组中创建结果值的函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">每个 <see cref="T:NewLife.Linq.IGrouping`2" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="resultSelector" /> 返回的结果值的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>连接两个序列。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含两个输入序列的连接元素。</returns>
            <param name="first">要连接的第一个序列。</param>
            <param name="second">要与第一个序列连接的序列。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NewLife.Reflection.Func{``0,``1,``2})">
            <summary>通过使用指定的谓词函数合并两个序列。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含两个输入序列的已合并元素。</returns>
            <param name="first">要合并的第一个序列。</param>
            <param name="second">要合并的第二个序列。</param>
            <param name="resultSelector">用于指定如何合并这两个序列的元素的函数。</param>
            <typeparam name="TFirst">第一个输入序列中的元素的类型。</typeparam>
            <typeparam name="TSecond">第二个输入序列中的元素的类型。</typeparam>
            <typeparam name="TResult">结果序列的元素的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>通过使用默认的相等比较器对值进行比较返回序列中的非重复元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含源序列中的非重复元素。</returns>
            <param name="source">要从中移除重复元素的序列。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>通过使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对值进行比较返回序列中的非重复元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含源序列中的非重复元素。</returns>
            <param name="source">要从中移除重复元素的序列。</param>
            <param name="comparer">用于比较值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>通过使用默认的相等比较器生成两个序列的并集。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含两个输入序列中的元素（重复元素除外）。</returns>
            <param name="first">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的非重复元素构成联合的第一个集。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的非重复元素构成联合的第二个集。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>通过使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 生成两个序列的并集。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含两个输入序列中的元素（重复元素除外）。</returns>
            <param name="first">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的非重复元素构成联合的第一个集。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的非重复元素构成联合的第二个集。</param>
            <param name="comparer">用于对值进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>通过使用默认的相等比较器对值进行比较生成两个序列的交集。</summary>
            <returns>包含组成两个序列交集的元素的序列。</returns>
            <param name="first">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将返回其也出现在 <paramref name="second" /> 中的非重复元素。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将返回其也出现在第一个序列中的非重复元素。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>通过使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对值进行比较以生成两个序列的交集。</summary>
            <returns>包含组成两个序列交集的元素的序列。</returns>
            <param name="first">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将返回其也出现在 <paramref name="second" /> 中的非重复元素。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将返回其也出现在第一个序列中的非重复元素。</param>
            <param name="comparer">用于比较值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>通过使用默认的相等比较器对值进行比较生成两个序列的差集。</summary>
            <returns>包含两个序列元素的差集的序列。</returns>
            <param name="first">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将返回其不在 <paramref name="second" /> 中的元素。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，如果它的元素也出现在第一个序列中，则将导致从返回的序列中移除这些元素。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>通过使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对值进行比较产生两个序列的差集。</summary>
            <returns>包含两个序列元素的差集的序列。</returns>
            <param name="first">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将返回其不在 <paramref name="second" /> 中的元素。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，如果它的元素也出现在第一个序列中，则将导致从返回的序列中移除这些元素。</param>
            <param name="comparer">用于比较值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>反转序列中元素的顺序。</summary>
            <returns>一个序列，其元素以相反顺序对应于输入序列的元素。</returns>
            <param name="source">要反转的值序列。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>通过使用相应类型的默认相等比较器对序列的元素进行比较，以确定两个序列是否相等。</summary>
            <returns>如果根据相应类型的默认相等比较器，两个源序列的长度相等，且其相应元素相等，则为 true；否则为 false。</returns>
            <param name="first">一个用于比较 <paramref name="second" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，用于与第一个序列进行比较。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对两个序列的元素进行比较，以确定序列是否相等。</summary>
            <returns>如果根据 <paramref name="comparer" />，两个源序列的长度相等，且其相应元素相等，则为 true；否则为 false。</returns>
            <param name="first">一个用于比较 <paramref name="second" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="second">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，用于与第一个序列进行比较。</param>
            <param name="comparer">一个用于比较元素的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">输入序列中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="first" /> 或 <paramref name="second" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" />具有多个元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的输入。</summary>
            <returns>类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的输入序列。</returns>
            <param name="source">类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的序列。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个数组。</summary>
            <returns>一个包含输入序列中的元素的数组。</returns>
            <param name="source">要从其创建数组的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:System.Collections.Generic.List`1" />。</summary>
            <returns>一个包含输入序列中元素的 <see cref="T:System.Collections.Generic.List`1" />。</returns>
            <param name="source">要从其创建 <see cref="T:System.Collections.Generic.List`1" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据指定的键选择器函数，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</summary>
            <returns>一个包含键和值的 <see cref="T:System.Collections.Generic.Dictionary`2" />。</returns>
            <param name="source">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将从它创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。- 或 -<paramref name="keySelector" /> 产生了一个 null 键。</exception>
            <exception cref="T:System.ArgumentException">
              <paramref name="keySelector" /> 为两个元素产生了重复键。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和键比较器，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</summary>
            <returns>一个包含键和值的 <see cref="T:System.Collections.Generic.Dictionary`2" />。</returns>
            <param name="source">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将从它创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。- 或 -<paramref name="keySelector" /> 产生了一个 null 键。</exception>
            <exception cref="T:System.ArgumentException">
              <paramref name="keySelector" /> 为两个元素产生了重复键。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2})">
            <summary>根据指定的键选择器和元素选择器函数，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.Dictionary`2" />，包含从输入序列中选择的类型为 <paramref name="TElement" /> 的值。</returns>
            <param name="source">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将从它创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="elementSelector">用于从每个元素产生结果元素值的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">
              <paramref name="elementSelector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 为 null。- 或 -<paramref name="keySelector" /> 产生了一个 null 键。</exception>
            <exception cref="T:System.ArgumentException">
              <paramref name="keySelector" /> 为两个元素产生了重复键。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数、比较器和元素选择器函数从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.Dictionary`2" />，包含从输入序列中选择的类型为 <paramref name="TElement" /> 的值。</returns>
            <param name="source">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，将从它创建一个 <see cref="T:System.Collections.Generic.Dictionary`2" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="elementSelector">用于从每个元素产生结果元素值的转换函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">
              <paramref name="elementSelector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 为 null。- 或 -<paramref name="keySelector" /> 产生了一个 null 键。</exception>
            <exception cref="T:System.ArgumentException">
              <paramref name="keySelector" /> 为两个元素产生了重复键。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>根据指定的键选择器函数，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:NewLife.Linq.Lookup`2" />。</summary>
            <returns>一个包含键和值的 <see cref="T:NewLife.Linq.Lookup`2" />。</returns>
            <param name="source">要从其创建 <see cref="T:NewLife.Linq.Lookup`2" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和键比较器，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:NewLife.Linq.Lookup`2" />。</summary>
            <returns>一个包含键和值的 <see cref="T:NewLife.Linq.Lookup`2" />。</returns>
            <param name="source">要从其创建 <see cref="T:NewLife.Linq.Lookup`2" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2})">
            <summary>根据指定的键选择器和元素选择器函数，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:NewLife.Linq.Lookup`2" />。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.Lookup`2" />，包含从输入序列中选择的类型为 <paramref name="TElement" /> 的值。</returns>
            <param name="source">要从其创建 <see cref="T:NewLife.Linq.Lookup`2" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="elementSelector">用于从每个元素产生结果元素值的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">
              <paramref name="elementSelector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1},NewLife.Reflection.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数、比较器和元素选择器函数，从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 创建一个 <see cref="T:NewLife.Linq.Lookup`2" />。</summary>
            <returns>一个 <see cref="T:NewLife.Linq.Lookup`2" />，包含从输入序列中选择的类型为 <paramref name="TElement" /> 的值。</returns>
            <param name="source">要从其创建 <see cref="T:NewLife.Linq.Lookup`2" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="keySelector">用于从每个元素中提取键的函数。</param>
            <param name="elementSelector">用于从每个元素产生结果元素值的转换函数。</param>
            <param name="comparer">一个用于对键进行比较的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TKey">
              <paramref name="keySelector" /> 返回的键的类型。</typeparam>
            <typeparam name="TElement">
              <paramref name="elementSelector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回指定序列的元素；如果序列为空，则返回单一实例集合中的类型参数的默认值。</summary>
            <returns>如果 <paramref name="source" /> 为空，则为包含 <paramref name="TSource" /> 类型的默认值的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 对象；否则为 <paramref name="source" />。</returns>
            <param name="source">序列为空时返回默认值的序列。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>返回指定序列中的元素；如果序列为空，则返回单一实例集合中的指定值。</summary>
            <returns>在 <paramref name="source" /> 为空的情况下包含 <paramref name="defaultValue" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />；否则为 <paramref name="source" />。</returns>
            <param name="source">序列为空时为其返回指定值的序列。</param>
            <param name="defaultValue">序列为空时要返回的值。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)">
            <summary>根据指定类型筛选 <see cref="T:System.Collections.IEnumerable" /> 的元素。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含类型为 <paramref name="TResult" /> 的输入序列中的元素。</returns>
            <param name="source">
              <see cref="T:System.Collections.IEnumerable" />，其元素用于筛选。</param>
            <typeparam name="TResult">筛选序列元素所根据的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)">
            <summary>将 <see cref="T:System.Collections.IEnumerable" /> 的元素转换为指定的类型。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含已转换为指定类型的源序列的每个元素。</returns>
            <param name="source">包含要转换的元素的 <see cref="T:System.Collections.IEnumerable" />。</param>
            <typeparam name="TResult">
              <paramref name="source" /> 中的元素要转换成的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidCastException">序列中的元素不能强制转换为 <paramref name="TResult" /> 类型。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列中的第一个元素。</summary>
            <returns>返回指定序列中的第一个元素。</returns>
            <param name="source">要返回其第一个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">源序列为空。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回序列中满足指定条件的第一个元素。</summary>
            <returns>序列中通过指定谓词函数中的测试的第一个元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">没有元素满足 <paramref name="predicate" /> 中的条件。- 或 -源序列为空。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列中的第一个元素；如果序列中不包含任何元素，则返回默认值。</summary>
            <returns>如果 <paramref name="source" /> 为空，则返回 default(<paramref name="TSource" />)；否则返回 <paramref name="source" /> 中的第一个元素。</returns>
            <param name="source">要返回其第一个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回序列中满足条件的第一个元素；如果未找到这样的元素，则返回默认值。</summary>
            <returns>如果 <paramref name="source" /> 为空或没有元素通过 <paramref name="predicate" /> 指定的测试，则返回 default(<paramref name="TSource" />)，否则返回 <paramref name="source" /> 中通过 <paramref name="predicate" /> 指定的测试的第一个元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列的最后一个元素。</summary>
            <returns>源序列中最后位置处的值。</returns>
            <param name="source">要返回其最后一个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">源序列为空。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回序列中满足指定条件的最后一个元素。</summary>
            <returns>序列中通过指定谓词函数中的测试的最后一个元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">没有元素满足 <paramref name="predicate" /> 中的条件。- 或 -源序列为空。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列中的最后一个元素；如果序列中不包含任何元素，则返回默认值。</summary>
            <returns>如果源序列为空，则返回 default(<paramref name="TSource" />)；否则返回 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 中的最后一个元素。</returns>
            <param name="source">要返回其最后一个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回序列中满足条件的最后一个元素；如果未找到这样的元素，则返回默认值。</summary>
            <returns>如果序列为空或没有元素通过谓词函数中的测试，则返回 default(<paramref name="TSource" />)；否则返回通过谓词函数中的测试的最后一个元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列的唯一元素；如果该序列并非恰好包含一个元素，则会引发异常。</summary>
            <returns>输入序列的单个元素。</returns>
            <param name="source">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，用于返回单个元素。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">输入序列包含多个元素。- 或 -输入序列为空。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回序列中满足指定条件的唯一元素；如果有多个这样的元素存在，则会引发异常。</summary>
            <returns>输入序列中满足条件的单个元素。</returns>
            <param name="source">要从中返回单个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">没有元素满足 <paramref name="predicate" /> 中的条件。- 或 -多个元素满足 <paramref name="predicate" /> 中的条件。- 或 -源序列为空。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列中的唯一元素；如果该序列为空，则返回默认值；如果该序列包含多个元素，此方法将引发异常。</summary>
            <returns>返回输入序列的单个元素；如果序列不包含任何元素，则返回 default(<paramref name="TSource" />)。</returns>
            <param name="source">要返回其单个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">输入序列包含多个元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回序列中满足指定条件的唯一元素；如果这类元素不存在，则返回默认值；如果有多个元素满足该条件，此方法将引发异常。</summary>
            <returns>如果未找到这样的元素，则返回输入序列中满足条件的单个元素或 default (<paramref name="TSource" />)。</returns>
            <param name="source">要从中返回单个元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">多个元素满足 <paramref name="predicate" /> 中的条件。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>返回序列中指定索引处的元素。</summary>
            <returns>源序列中指定位置处的元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="index">要检索的从零开始的元素索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index" /> 小于零或大于等于 <paramref name="source" /> 中的元素数量。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>返回序列中指定索引处的元素；如果索引超出范围，则返回默认值。</summary>
            <returns>如果索引超出源序列的范围，则为 default(<paramref name="TSource" />)；否则为源序列中指定位置处的元素。</returns>
            <param name="source">要从中返回元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="index">要检索的从零开始的元素索引。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Range(System.Int32,System.Int32)">
            <summary>生成指定范围内的整数的序列。</summary>
            <returns>C# 中的 IEnumerable&lt;Int32&gt; 或 Visual Basic 中包含某个范围内的顺序整数的 IEnumerable(Of Int32)。</returns>
            <param name="start">序列中第一个整数的值。</param>
            <param name="count">要生成的顺序整数的数目。</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="count" /> 小于 0。- 或 -<paramref name="start" /> + <paramref name="count" /> -1 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Repeat``1(``0,System.Int32)">
            <summary>生成包含一个重复值的序列。</summary>
            <returns>一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含一个重复值。</returns>
            <param name="element">要重复的值。</param>
            <param name="count">在生成序列中重复该值的次数。</param>
            <typeparam name="TResult">要在结果序列中重复的值的类型。</typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="count" /> 小于 0。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Empty``1">
            <summary>返回一个具有指定的类型参数的空 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
            <returns>一个类型参数为 <paramref name="TResult" /> 的空 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</returns>
            <typeparam name="TResult">分配给返回的泛型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的类型参数的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>确定序列是否包含任何元素。</summary>
            <returns>如果源序列包含任何元素，则为 true；否则为 false。</returns>
            <param name="source">要检查是否为空的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>确定序列中的任何元素是否都满足条件。</summary>
            <returns>如果源序列中的任何元素都通过指定谓词中的测试，则为 true；否则为 false。</returns>
            <param name="source">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其元素将应用谓词。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>确定序列中的所有元素是否满足条件。</summary>
            <returns>如果源序列中的每个元素都通过指定谓词中的测试，或者序列为空，则为 true；否则为 false。</returns>
            <param name="source">包含要应用谓词的元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回序列中的元素数量。</summary>
            <returns>输入序列中的元素数量。</returns>
            <param name="source">包含要计数的元素的序列。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">
              <paramref name="source" /> 中的元素数量大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回一个数字，表示在指定的序列中满足条件的元素数量。</summary>
            <returns>一个数字，表示序列中满足谓词函数条件的元素数量。</returns>
            <param name="source">包含要测试和计数的元素的序列。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">
              <paramref name="source" /> 中的元素数量大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回一个 <see cref="T:System.Int64" />，表示序列中的元素的总数量。</summary>
            <returns>源序列中的元素的数量。</returns>
            <param name="source">包含要进行计数的元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">元素的数量超过 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Boolean})">
            <summary>返回一个 <see cref="T:System.Int64" />，表示序列中满足条件的元素的数量。</summary>
            <returns>一个数字，表示序列中满足谓词函数条件的元素数量。</returns>
            <param name="source">包含要进行计数的元素的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="predicate">用于测试每个元素是否满足条件的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="predicate" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">匹配元素的数量超过 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>通过使用默认的相等比较器确定序列是否包含指定的元素。</summary>
            <returns>如果源序列包含具有指定值的元素，则为 true；否则为 false。</returns>
            <param name="source">要在其中定位某个值的序列。</param>
            <param name="value">要在序列中定位的值。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>通过使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 确定序列是否包含指定的元素。</summary>
            <returns>如果源序列包含具有指定值的元素，则为 true；否则为 false。</returns>
            <param name="source">要在其中定位某个值的序列。</param>
            <param name="value">要在序列中定位的值。</param>
            <param name="comparer">一个对值进行比较的相等比较器。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``0,``0})">
            <summary>对序列应用累加器函数。</summary>
            <returns>累加器的最终值。</returns>
            <param name="source">要聚合的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="func">要对每个元素调用的累加器函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="func" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,NewLife.Reflection.Func{``1,``0,``1})">
            <summary>对序列应用累加器函数。将指定的种子值用作累加器初始值。</summary>
            <returns>累加器的最终值。</returns>
            <param name="source">要聚合的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="seed">累加器的初始值。</param>
            <param name="func">要对每个元素调用的累加器函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TAccumulate">累加器值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="func" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,NewLife.Reflection.Func{``1,``0,``1},NewLife.Reflection.Func{``1,``2})">
            <summary>对序列应用累加器函数。将指定的种子值用作累加器的初始值，并使用指定的函数选择结果值。</summary>
            <returns>已转换的累加器最终值。</returns>
            <param name="source">要聚合的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
            <param name="seed">累加器的初始值。</param>
            <param name="func">要对每个元素调用的累加器函数。</param>
            <param name="resultSelector">将累加器的最终值转换为结果值的函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TAccumulate">累加器值的类型。</typeparam>
            <typeparam name="TResult">结果值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="func" /> 或 <paramref name="resultSelector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>计算 <see cref="T:System.Int32" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">一个要计算和的 <see cref="T:System.Int32" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int32" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">要计算和的可以为 null 的 <see cref="T:System.Int32" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>计算 <see cref="T:System.Int64" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">一个要计算和的 <see cref="T:System.Int64" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int64" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">要计算和的可以为 null 的 <see cref="T:System.Int64" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>计算 <see cref="T:System.Single" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">一个要计算和的 <see cref="T:System.Single" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>计算可以为 null 的 <see cref="T:System.Single" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">要计算和的可以为 null 的 <see cref="T:System.Single" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>计算 <see cref="T:System.Double" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">一个要计算和的 <see cref="T:System.Double" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>计算可以为 null 的 <see cref="T:System.Double" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">要计算和的可以为 null 的 <see cref="T:System.Double" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>计算 <see cref="T:System.Decimal" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">一个要计算和的 <see cref="T:System.Decimal" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>计算可以为 null 的 <see cref="T:System.Decimal" /> 值序列之和。</summary>
            <returns>序列值之和。</returns>
            <param name="source">要计算和的可以为 null 的 <see cref="T:System.Decimal" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32})">
            <summary>计算 <see cref="T:System.Int32" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int32}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int32" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int64})">
            <summary>计算 <see cref="T:System.Int64" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int64}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int64" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Single})">
            <summary>计算 <see cref="T:System.Single" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Single}})">
            <summary>计算可以为 null 的 <see cref="T:System.Single" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Double})">
            <summary>计算 <see cref="T:System.Double" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Double}})">
            <summary>计算可以为 null 的 <see cref="T:System.Double" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Decimal})">
            <summary>计算 <see cref="T:System.Decimal" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Decimal}})">
            <summary>计算可以为 null 的 <see cref="T:System.Decimal" /> 值序列的和，这些值是通过对输入序列中的每个元素调用转换函数得来的。</summary>
            <returns>投影值之和。</returns>
            <param name="source">用于计算和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>返回 <see cref="T:System.Int32" /> 值序列中的最小值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个 <see cref="T:System.Int32" /> 值序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>返回 <see cref="T:System.Int32" /> 值（可空）序列中的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Int32&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Int32)。</returns>
            <param name="source">一个可空 <see cref="T:System.Int32" /> 值的序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>返回 <see cref="T:System.Int64" /> 值序列中的最小值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个 <see cref="T:System.Int64" /> 值序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>返回 <see cref="T:System.Int64" /> 值（可空）序列中的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Int64&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Int64)。</returns>
            <param name="source">一个可空 <see cref="T:System.Int64" /> 值的序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>返回 <see cref="T:System.Single" /> 值序列中的最小值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个 <see cref="T:System.Single" /> 值序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>返回 <see cref="T:System.Single" /> 值（可空）序列中的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Single&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Single)。</returns>
            <param name="source">一个可空 <see cref="T:System.Single" /> 值的序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>返回 <see cref="T:System.Double" /> 值序列中的最小值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个 <see cref="T:System.Double" /> 值序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>返回 <see cref="T:System.Double" /> 值（可空）序列中的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Double&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Double)。</returns>
            <param name="source">一个可空 <see cref="T:System.Double" /> 值的序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>返回 <see cref="T:System.Decimal" /> 值序列中的最小值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个 <see cref="T:System.Decimal" /> 值序列，用于确定最大值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>返回 <see cref="T:System.Decimal" /> 值（可空）序列中的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Decimal&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Decimal)。</returns>
            <param name="source">一个可空 <see cref="T:System.Decimal" /> 值的序列，用于确定最小值。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回泛型序列中的最小值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32})">
            <summary>调用序列的每个元素上的转换函数并返回最小 <see cref="T:System.Int32" /> 值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int32}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Int32" /> 的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Int32&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Int32)。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int64})">
            <summary>调用序列的每个元素上的转换函数并返回最小 <see cref="T:System.Int64" /> 值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int64}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Int64" /> 的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Int64&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Int64)。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Single})">
            <summary>调用序列的每个元素上的转换函数并返回最小 <see cref="T:System.Single" /> 值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Single}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Single" /> 的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Single&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Single)。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Double})">
            <summary>调用序列的每个元素上的转换函数并返回最小 <see cref="T:System.Double" /> 值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Double}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Double" /> 的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Double&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Double)。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Decimal})">
            <summary>调用序列的每个元素上的转换函数并返回最小 <see cref="T:System.Decimal" /> 值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Decimal}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Decimal" /> 的最小值。</summary>
            <returns>C# 中类型为 Nullable&lt;Decimal&gt; 的值或 Visual Basic 中与序列中最小值对应的 Nullable(Of Decimal)。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>调用泛型序列的每个元素上的转换函数并返回最小结果值。</summary>
            <returns>序列中的最小值。</returns>
            <param name="source">一个值序列，用于确定最小值。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="selector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>返回 <see cref="T:System.Int32" /> 值序列中的最大值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的 <see cref="T:System.Int32" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>返回可以为 null 的 <see cref="T:System.Int32" /> 值序列中的最大值。</summary>
            <returns>一个与序列中的最大值对应的值，该值的类型在 C# 中为 Nullable&lt;Int32&gt;，在 Visual Basic 中为 Nullable(Of Int32)。</returns>
            <param name="source">要确定其最大值的可以为 null 的 <see cref="T:System.Int32" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>返回 <see cref="T:System.Int64" /> 值序列中的最大值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的 <see cref="T:System.Int64" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>返回可以为 null 的 <see cref="T:System.Int64" /> 值序列中的最大值。</summary>
            <returns>一个与序列中的最大值对应的值，该值的类型在 C# 中为 Nullable&lt;Int64&gt;，在 Visual Basic 中为 Nullable(Of Int64)。</returns>
            <param name="source">要确定其最大值的可以为 null 的 <see cref="T:System.Int64" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>返回 <see cref="T:System.Double" /> 值序列中的最大值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的 <see cref="T:System.Double" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>返回可以为 null 的 <see cref="T:System.Double" /> 值序列中的最大值。</summary>
            <returns>一个与序列中的最大值对应的值，该值的类型在 C# 中为 Nullable&lt;Double&gt;，在 Visual Basic 中为 Nullable(Of Double)。</returns>
            <param name="source">要确定其最大值的可以为 null 的 <see cref="T:System.Double" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>返回 <see cref="T:System.Single" /> 值序列中的最大值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的 <see cref="T:System.Single" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>返回可以为 null 的 <see cref="T:System.Single" /> 值序列中的最大值。</summary>
            <returns>一个与序列中的最大值对应的值，该值的类型在 C# 中为 Nullable&lt;Single&gt;，在 Visual Basic 中为 Nullable(Of Single)。</returns>
            <param name="source">要确定其最大值的可以为 null 的 <see cref="T:System.Single" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>返回 <see cref="T:System.Decimal" /> 值序列中的最大值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的 <see cref="T:System.Decimal" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>返回可以为 null 的 <see cref="T:System.Decimal" /> 值序列中的最大值。</summary>
            <returns>一个与序列中的最大值对应的值，该值的类型在 C# 中为 Nullable&lt;Decimal&gt;，在 Visual Basic 中为 Nullable(Of Decimal)。</returns>
            <param name="source">要确定其最大值的可以为 null 的 <see cref="T:System.Decimal" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>返回泛型序列中的最大值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32})">
            <summary>调用序列的每个元素上的转换函数并返回最大 <see cref="T:System.Int32" /> 值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int32}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Int32" /> 的最大值。</summary>
            <returns>C# 中类型为 Nullable&lt;Int32&gt; 的值或 Visual Basic 中与序列中最大值对应的 Nullable(Of Int32)。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int64})">
            <summary>调用序列的每个元素上的转换函数并返回最大 <see cref="T:System.Int64" /> 值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int64}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Int64" /> 的最大值。</summary>
            <returns>C# 中类型为 Nullable&lt;Int64&gt; 的值或 Visual Basic 中与序列中最大值对应的 Nullable(Of Int64)。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Single})">
            <summary>调用序列的每个元素上的转换函数并返回最大 <see cref="T:System.Single" /> 值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Single}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Single" /> 的最大值。</summary>
            <returns>C# 中类型为 Nullable&lt;Single&gt; 的值或 Visual Basic 中与序列中最大值对应的 Nullable(Of Single)。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Double})">
            <summary>调用序列的每个元素上的转换函数并返回最大 <see cref="T:System.Double" /> 值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Double}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Double" /> 的最大值。</summary>
            <returns>C# 中类型为 Nullable&lt;Double&gt; 的值或 Visual Basic 中与序列中最大值对应的 Nullable(Of Double)。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Decimal})">
            <summary>调用序列的每个元素上的转换函数并返回最大 <see cref="T:System.Decimal" /> 值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Decimal}})">
            <summary>调用序列的每个元素上的转换函数并返回可空 <see cref="T:System.Decimal" /> 的最大值。</summary>
            <returns>C# 中类型为 Nullable&lt;Decimal&gt; 的值或 Visual Basic 中与序列中最大值对应的 Nullable(Of Decimal)。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,``1})">
            <summary>调用泛型序列的每个元素上的转换函数并返回最大结果值。</summary>
            <returns>序列中的最大值。</returns>
            <param name="source">要确定其最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <typeparam name="TResult">
              <paramref name="selector" /> 返回的值的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>计算 <see cref="T:System.Int32" /> 值序列的平均值。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算平均值的 <see cref="T:System.Int32" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int32" /> 值序列的平均值。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算平均值的可以为 null 的 <see cref="T:System.Int32" />值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>计算 <see cref="T:System.Int64" /> 值序列的平均值。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算平均值的 <see cref="T:System.Int64" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int64" /> 值序列的平均值。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算平均值的可以为 null 的 <see cref="T:System.Int64" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>计算 <see cref="T:System.Single" /> 值序列的平均值。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算平均值的 <see cref="T:System.Single" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>计算可以为 null 的 <see cref="T:System.Single" /> 值序列的平均值。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算平均值的可以为 null 的 <see cref="T:System.Single" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>计算 <see cref="T:System.Double" /> 值序列的平均值。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算平均值的 <see cref="T:System.Double" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>计算可以为 null 的 <see cref="T:System.Double" /> 值序列的平均值。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算平均值的可以为 null 的 <see cref="T:System.Double" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>计算 <see cref="T:System.Decimal" /> 值序列的平均值。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算平均值的 <see cref="T:System.Decimal" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>计算可以为 null 的 <see cref="T:System.Decimal" /> 值序列的平均值。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算平均值的可以为 null 的 <see cref="T:System.Decimal" /> 值序列。</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int32})">
            <summary>计算 <see cref="T:System.Int32" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int32}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int32" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Int64})">
            <summary>计算 <see cref="T:System.Int64" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">source 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Int64}})">
            <summary>计算可以为 null 的 <see cref="T:System.Int64" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Single})">
            <summary>计算 <see cref="T:System.Single" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Single}})">
            <summary>计算可以为 null 的 <see cref="T:System.Single" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Double})">
            <summary>计算 <see cref="T:System.Double" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Double}})">
            <summary>计算可以为 null 的 <see cref="T:System.Double" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Decimal})">
            <summary>计算 <see cref="T:System.Decimal" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值。</returns>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.InvalidOperationException">
              <paramref name="source" /> 中不包含任何元素。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},NewLife.Reflection.Func{``0,System.Nullable{System.Decimal}})">
            <summary>计算可以为 null 的 <see cref="T:System.Decimal" /> 值序列的平均值，该值可通过调用输入序列的每个元素的转换函数获取。</summary>
            <returns>值序列的平均值；如果源序列为空或仅包含为 null 的值，则为 null。</returns>
            <param name="source">要计算其平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <typeparam name="TSource">
              <paramref name="source" /> 中的元素的类型。</typeparam>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source" /> 或 <paramref name="selector" /> 为 null。</exception>
            <exception cref="T:System.OverflowException">序列中元素之和大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
        </member>
        <member name="T:NewLife.Messaging.StringMessage">
            <summary>字符串消息。封装一个字符串，UTF8编码。</summary>
        </member>
        <member name="M:NewLife.Messaging.StringMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.StringMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.StringMessage.Value">
            <summary>字符串</summary>
        </member>
        <member name="T:NewLife.Messaging.EntitiesMessage">
            <summary>指定类型的实体对象数组消息</summary>
            <remarks>
            有些列表对象不适合直接序列化，并且不方便每次都进行转换，（如XCode的EntityList），此时适合用实体数组消息。
            实体对象个数由<see cref="P:NewLife.Messaging.EntitiesMessage.Values"/>决定，以编码整数来存储。
            不写长度，所以<see cref="T:NewLife.Messaging.Message"/>为空时后面不能有其它包
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.EntitiesMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.EntitiesMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.EntitiesMessage.Type">
            <summary>实体类型。可以是接口或抽象类型（要求对象容器能识别）</summary>
        </member>
        <member name="P:NewLife.Messaging.EntitiesMessage.Values">
            <summary>实体列表</summary>
        </member>
        <member name="T:NewLife.Collections.ListBase`1">
            <summary>泛型列表基类。主要提供一个重载实现自定义列表的基类实现。</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Add(`0)">
            <summary>添加</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Clear">
            <summary>清空</summary>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Contains(`0)">
            <summary>是否包含指定元素</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.CopyTo(`0[],System.Int32)">
            <summary>把元素复制到一个数组里面</summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.GetEnumerator">
            <summary>获取一个枚举器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.IndexOf(`0)">
            <summary>确定列表中特定项的索引。</summary>
            <param name="value">要在列表中定位的对象。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Insert(System.Int32,`0)">
            <summary>将一个项插入指定索引处的列表。</summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Remove(`0)">
            <summary>从列表中移除指定对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.RemoveAt(System.Int32)">
            <summary>移除指定索引处的列表项。</summary>
            <param name="index"></param>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.InnerList">
            <summary>内部列表</summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.Count">
            <summary>列表元素个数</summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.IsFixedSize">
            <summary>是否固定大小</summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.IsReadOnly">
            <summary>是否只读</summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.Item(System.Int32)">
            <summary>获取或设置指定索引处的元素。</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadTask">
            <summary>线程任务</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadTask.#ctor(System.Threading.WaitCallback,System.Object)">
            <summary>构造一个线程任务</summary>
            <param name="method">任务方法</param>
            <param name="argument">任务参数</param>
        </member>
        <member name="M:NewLife.Threading.ThreadTask.#ctor(System.Threading.WaitCallback,System.Threading.WaitCallback,System.Object)">
            <summary>构造一个线程任务</summary>
            <param name="method">任务方法</param>
            <param name="abortMethod">任务被取消时执行的方法</param>
            <param name="argument">任务参数</param>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.ID">
            <summary>唯一编号</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.Method">
            <summary>任务方法</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.Argument">
            <summary>任务参数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.AbortMethod">
            <summary>取消任务时执行的方法</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.newID">
            <summary>取一个新编号</summary>
        </member>
        <member name="T:NewLife.Serialization.NameValueSetting">
            <summary>名值读写器设置</summary>
        </member>
        <member name="P:NewLife.Serialization.NameValueSetting.Separator">
            <summary>分隔符</summary>
        </member>
        <member name="P:NewLife.Serialization.NameValueSetting.Connector">
            <summary>连接符</summary>
        </member>
        <member name="T:NewLife.Serialization.ReadMemberEventArgs">
            <summary>读取成员事件参数</summary>
        </member>
        <member name="M:NewLife.Serialization.ReadMemberEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>实例化</summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Index">
            <summary>成员序号</summary>
        </member>
        <member name="T:NewLife.Serialization.SimpleMemberInfo">
            <summary>简单成员信息</summary>
        </member>
        <member name="M:NewLife.Serialization.SimpleMemberInfo.#ctor(System.String,System.Type,System.Object)">
            <summary>实例化</summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.SimpleMemberInfo.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.Item(System.Object)">
            <summary>对目标对象取值赋值</summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Json.SimpleJsonUtil">
            <summary>简单Json工具,不需要创建实体类就可以读取和生成Json</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.From(System.String)">
            <summary>从指定json字符串读取出Json值</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.From(System.IO.TextReader)">
            <summary>从指定文本读取流读出Json值</summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Read(NewLife.Serialization.JsonAtomStringReader)">
            <summary>从指定Json原子元素读取流读出一个Json值,包括对象和数组</summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.ReadObject(NewLife.Serialization.JsonAtomStringReader)">
            <summary>读取一个Json对象值</summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.ReadArray(NewLife.Serialization.JsonAtomStringReader)">
            <summary>读取一个数组值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.ParseInteger(System.String)">
            <summary>尝试从指定字符串解析返回一个代表整型数字的SimpleJson对象</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.ParseFloat(System.String)">
            <summary>尝试从指定字符串解析返回一个代表浮点型数字的SimpleJson对象</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Value(System.Object)">
            <summary>根据传入的值选择合适的SimpleJson返回,如果不是基础类型则返回Type为Unknown的Json值,生成Json字符串时,可以指定ToJson事件以实现比如DateTime类型的生成</summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Undefined">
            <summary>返回一个js undefined的值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Null">
            <summary>返回一个js null的值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Boolean(System.Boolean)">
            <summary>返回一个js 布尔型值</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Number(System.Int32)">
            <summary>返回一个js 整型数字</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Number(System.Int64)">
            <summary>返回一个js 长整型数字,其在js中的表现和整型完全一样</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Number(System.Single)">
            <summary>返回一个js 浮点数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Number(System.Double)">
            <summary>返回一个js 双精度浮点数,其在js中的表现和浮点数完全一样</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.String(System.String)">
            <summary>返回一个js 字符串值</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Object(System.Object[])">
            <summary>返回一个js 对象值</summary>
            <param name="args">名值对,必须是成对出现,否则将会抛弃最后一个</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.Array(System.Object[])">
            <summary>返回一个js 数组值</summary>
            <param name="args">值,可以直接指定基础类型如int string这些</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.To(NewLife.Serialization.Json.SimpleJson,System.IO.TextWriter)">
            <summary>将指定Json值写入到指定的文本写入流</summary>
            <param name="value"></param>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.To(NewLife.Serialization.Json.SimpleJson)">
            <summary>返回指定Json值的Json字符串</summary>
            <remarks>
            如果value是一个Unknown/Undefined类型的值,则返回空白字符串,但是如果value下的对象或数组的中有Unknown/Undefined类型的值,则会尽可能修正为null或忽略(在数组结尾的Unknown/Undefined类型值会忽略)以符合Json标准
            </remarks>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil._To(NewLife.Serialization.Json.SimpleJson)">
            <summary>返回指定Json值的Json字符串,私有方法</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.ToObject(NewLife.Serialization.Json.SimpleJson)">
            <summary>返回指定Json对象的Json字符串</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.ToArray(NewLife.Serialization.Json.SimpleJson)">
            <summary>返回指定Json数组的Json字符串</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.StringProcess(System.String,System.Object[])">
            <summary>使用指定的处理方式处理指定字符串</summary>
            <remarks>
            处理方式有2种类型
              Func&lt;char, string&gt;(用于按字符处理,其中一个返回非null即表示当前字符转换成功)
              Func&lt;string, string&gt;(用于在最后处理整个字符串,会按照顺序全部调用)
            </remarks>
            <param name="value"></param>
            <param name="args">处理方式</param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonUtil.JsStringInDoubleQuote">
            <summary>在双引号中使用的js字符串的处理方式</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonUtil.JsStringInSingleQuote">
            <summary>在单引号中间使用的js字符串处理方式</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonUtil.DoubleQuote">
            <summary>在指定字符串两边加上双引号的处理方式</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonUtil.SingleQuote">
            <summary>在指定字符串两边加上单引号的处理方式</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonUtil.EncodeUnicode">
            <summary>转换Unicode字符为\uXXXX形式的处理方式</summary>
            <remarks>
            解码方法参见 JsonAtomStringReader.TryDecodeUnicode
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.JsString(System.Char)">
             <summary>返回在StringProcess方法中使用的处理方式,用于将输入的字符串转换为Js字符串字面值</summary>
             <remarks>
             可指定是在什么引号中使用的字符串,如果既不是单引号也不是双引号则所有"和'符号都会使用转义符号\
            
             返回结果不包含字符串两边的引号
             </remarks>
             <param name="quoto">单引号或双引号,或未知0</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.JsStringDefine(System.String)">
            <summary>返回一个在Js代码中使用的Js字符串声明赋值的值部分</summary>
            <remarks>
            <code>
              var a=&lt;%=JsStringDefine("foo bar") %&gt;;
            </code>
            </remarks>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJsonUtil.JsStringDefine(System.String,System.Boolean)">
            <summary>返回一个在Js代码中使用的Js字符串声明复制的值部分,可指定字符串赋值使用单引号还是双引号</summary>
            <param name="str"></param>
            <param name="useSingleQuote">true表示使用单引号,否则使用双引号</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJsonUtil.IsEncodeUnicode">
            <summary>设置在产生Json字符串的时候是否编码Unicode字符为\uXXXX的格式</summary>
        </member>
        <member name="E:NewLife.Serialization.Json.SimpleJsonUtil.BeginFromJson">
            <summary>当开始解析一段Json字符串时触发的事件</summary>
        </member>
        <member name="E:NewLife.Serialization.Json.SimpleJsonUtil.FromJson">
            <summary>当解析到一段Json值时触发</summary>
        </member>
        <member name="E:NewLife.Serialization.Json.SimpleJsonUtil.EndFromJson">
            <summary>当完成解析一段Json字符串时触发</summary>
        </member>
        <member name="E:NewLife.Serialization.Json.SimpleJsonUtil.BeginToJson">
            <summary>当开始从Json值产生字符串时触发</summary>
        </member>
        <member name="E:NewLife.Serialization.Json.SimpleJsonUtil.ToJson">
            <summary>当产生了一个Json值对应的Json字符串时触发</summary>
        </member>
        <member name="E:NewLife.Serialization.Json.SimpleJsonUtil.EndToJson">
            <summary>当完成从Json值产生字符串时触发</summary>
        </member>
        <member name="T:NewLife.Serialization.Json.SimpleJson">
            <summary>简单Json值</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJson.Get(System.String)">
            <summary>使用检索字符串检索当前Json值</summary>
            <remarks>
            检索字符串很类似js,可以象在js中访问json对象一样访问SimpleJson对象树
            </remarks>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJson.Get``1">
            <summary>将当前Json值的实际值转换成指定类型返回</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJson.Get``1(System.String)">
            <summary>使用检索字符串检索当前Json值的实际值,并转换为T类型</summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJson.Get``1(System.String,``0)">
            <summary>使用检索字符串检索当前Json值的实际值,并转换为T类型,如果转换失败将返回_default</summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="_default"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJson.TryGet``1(``0@)">
            <summary>将当前Json值的实际值转换成指定类型返回,如果类型不匹配将返回T类型的默认值</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.SimpleJson.ToString">
            <summary>重载</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.Type">
            <summary>值类型</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.Value">
            <summary>值,实际类型取决于Type属性</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.IsUndefined">
            <summary>易用的方法,返回当前值是否是未定义</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.IsUnknown">
            <summary>易用的方法,返回当前值是否是未知的值</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.Count">
            <summary>返回对象或数组的元素总数,非对象和数组的情况下返回0</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.Keys">
             <summary>
             返回对象的所有成员名称,非对象的情况下返回长度为0的数组
            
             并不保证成员名称顺序和声明时顺序一致
             </summary>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.Item(System.Int32)">
            <summary>按下标索引,只在Type为数组是生效,如果不是数组或不存在将返回Undefined</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Json.SimpleJson.Item(System.String)">
            <summary>按名称索引,只在Type为对象是生效,如果不是对象或不存在将返回Undefined</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Json.SimpleJsonType">
            <summary>简单Json值类型,针对SimpleJsonReader的需要,对JsonAtomType的一些精简,并提供js中Undefined类型</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Unknown">
            <summary>未知,不属于基础Json类型的类型</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Object">
            <summary>对象类型,即{"key":"value"}</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Array">
            <summary>数组类型,即["value",1,2,3]</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.String">
            <summary>字符串</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Integer">
            <summary>整数</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Float">
            <summary>浮点数</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Boolean">
            <summary>布尔型,true/false</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Null">
            <summary>null</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Literal">
            <summary>字面值,用于处理不严谨的json字符串,比如{aa:'bb'}</summary>
        </member>
        <member name="F:NewLife.Serialization.Json.SimpleJsonType.Undefined">
            <summary>未初始化的值,用于处理不严谨的json字符串,比如[,,]</summary>
        </member>
        <member name="T:NewLife.Reflection.ApiHook">
            <summary>API钩子</summary>
            <remarks>
            实现上，是两个方法的非托管指针互换，为了方便后面换回来。
            但是很奇怪，UnHook换回来后，执行的代码还是更换后的，也就是无法复原。
            
            一定要注意，在vs中调试会导致Hook失败，尽管换了指针，也无法变更代码执行流程。
            </remarks>
        </member>
        <member name="M:NewLife.Reflection.ApiHook.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.Reflection.ApiHook.Hook">
            <summary>挂钩</summary>
        </member>
        <member name="M:NewLife.Reflection.ApiHook.UnHook">
            <summary>取消挂钩</summary>
        </member>
        <member name="M:NewLife.Reflection.ApiHook.GetMethodAddress(System.Reflection.MethodBase)">
            <summary>获取方法在JIT编译后的地址(JIT Stubs)</summary>
            <remarks>
            MethodBase.DeclaringType.TypeHandle.Value: 指向该类型方法表(编译后)在 JIT Stubs 的起始位置。
            Method.MethodHandle.Value: 表示该方法的索引序号。
            CLR 2.0 SP2 (2.0.50727.3053) 及其后续版本中，该地址的内存布局发生了变化。直接用 "Method.MethodHandle.Value + 2" 即可得到编译后的地址。
            </remarks>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ApiHook.ReplaceMethod(System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <summary>替换方法</summary>
            <remarks>
            Method Address 处所存储的 Native Code Address 是可以修改的，也就意味着我们完全可以用另外一个具有相同签名的方法来替代它，从而达到偷梁换柱(Injection)的目的。
            </remarks>
            <param name="src"></param>
            <param name="des"></param>
        </member>
        <member name="P:NewLife.Reflection.ApiHook.OriMethod">
            <summary>原始方法</summary>
        </member>
        <member name="P:NewLife.Reflection.ApiHook.NewMethod">
            <summary>新方法</summary>
        </member>
        <member name="T:NewLife.Model.ServiceContainer`1">
            <summary>服务容器基类。使用泛型基类，仅仅是为了引发子类的静态构造函数。</summary>
            <typeparam name="TService">具体服务容器类</typeparam>
            <remarks>
            建议各个组件通过继承当前类实现一个私有的服务定位器，用于为组件内提供服务定位服务。
            组件内部的默认实现可以在静态构造函数中进行无覆盖注册。
            作为约定，组件内部的服务定位全部通过该类完成，保证服务在使用前已完成了注册。
            </remarks>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.Register``2(System.Object,System.Int32)">
            <summary>注册类型和名称</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">实现类型</typeparam>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.Register``1(System.Type,System.Object)">
            <summary>注册</summary>
            <typeparam name="T"></typeparam>
            <param name="impl"></param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.Resolve(System.Type,System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <param name="type"></param>
            <param name="id">标识</param>
            <param name="extend"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.Resolve``1(System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.ResolveInstance(System.Type,System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <param name="type"></param>
            <param name="id">标识</param>
            <param name="extend"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.ResolveInstance``1(System.Object,System.Boolean)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceContainer`1.ResolveType``1(System.Object,System.Boolean)">
            <summary>解析类型</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="id">标识</param>
            <param name="extend">扩展。若为ture，name为null而找不到时，采用第一个注册项；name不为null而找不到时，采用null注册项</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Model.ServiceContainer`1.Container">
            <summary>当前对象容器</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageEventArgs">
            <summary>消息事件参数</summary>
        </member>
        <member name="M:NewLife.Messaging.MessageEventArgs.#ctor(NewLife.Messaging.Message)">
            <summary>实例化</summary>
            <param name="message"></param>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Message">
            <summary>消息</summary>
        </member>
        <member name="T:NewLife.Xml.ExtendData">
            <summary>使用Xml来存储字典扩展数据，不怕序列化和混淆</summary>
        </member>
        <member name="M:NewLife.Xml.ExtendData.GetItem``1(System.String)">
            <summary>取得指定键的强类型值</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.ExtendData.SetItem(System.String,System.Object)">
            <summary>设置类型</summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Xml.ExtendData.Contain(System.String)">
            <summary>包含指定键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.ExtendData.Remove(System.String)">
            <summary>移除指定项</summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Xml.ExtendData.FromXml(System.String)">
            <summary>从Xml转为具体数据</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.ExtendData.ToXml">
            <summary>转为Xml</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Xml.ExtendData.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Xml.ExtendData.XmlKeys">
            <summary>Xml数据键值</summary>
        </member>
        <member name="P:NewLife.Xml.ExtendData.Root">
            <summary>根名称</summary>
        </member>
        <member name="P:NewLife.Xml.ExtendData.Item(System.String)">
            <summary>读取设置数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Xml.ExtendData.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="T:NewLife.Threading.SpinWait">
            <summary>提供对基于自旋的等待的支持。</summary>
        </member>
        <member name="M:NewLife.Threading.SpinWait.SpinOnce">
            <summary>执行单一自旋。</summary>
        </member>
        <member name="M:NewLife.Threading.SpinWait.Reset">
            <summary>重置自旋计数器。</summary>
        </member>
        <member name="M:NewLife.Threading.SpinWait.SpinUntil(NewLife.Reflection.Func{System.Boolean})">
            <summary>在指定条件得到满足之前自旋。</summary>
            <param name="condition">在返回 true 之前重复执行的委托。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> 参数为 null。</exception>
        </member>
        <member name="M:NewLife.Threading.SpinWait.SpinUntil(NewLife.Reflection.Func{System.Boolean},System.TimeSpan)">
            <summary>在指定条件得到满足或指定超时过期之前自旋。</summary>
            <returns>如果条件在超时时间内得到满足，则为 true；否则为 false</returns>
            <param name="condition">在返回 true 之前重复执行的委托。</param>
            <param name="timeout">一个 <see cref="T:System.TimeSpan" />，表示等待的毫秒数；或者一个 TimeSpan，表示 -1 毫秒（无限期等待）。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> 参数为 null。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        </member>
        <member name="M:NewLife.Threading.SpinWait.SpinUntil(NewLife.Reflection.Func{System.Boolean},System.Int32)">
            <summary>在指定条件得到满足或指定超时过期之前自旋。</summary>
            <returns>如果条件在超时时间内得到满足，则为 true；否则为 false</returns>
            <param name="condition">在返回 true 之前重复执行的委托。</param>
            <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> 参数为 null。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        </member>
        <member name="P:NewLife.Threading.SpinWait.Count">
            <summary>获取已对此实例调用 <see cref="M:NewLife.Threading.SpinWait.SpinOnce"/> 的次数。</summary>
        </member>
        <member name="P:NewLife.Threading.SpinWait.NextSpinWillYield">
            <summary>获取对 <see cref="M:NewLife.Threading.SpinWait.SpinOnce"/> 的下一次调用是否将产生处理器，同时触发强制上下文切换。</summary>
            <returns>对 <see cref="M:NewLife.Threading.SpinWait.SpinOnce"/> 的下一次调用是否将产生处理器，同时触发强制上下文切换。</returns>
        </member>
        <member name="T:NewLife.WeakReference`1">
            <summary>弱引用</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor(`0)">
            <summary>实例化</summary>
            <param name="target"></param>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>实例化</summary>
            <param name="target"></param>
            <param name="trackResurrection"></param>
        </member>
        <member name="M:NewLife.WeakReference`1.TryGetTarget(`0@)">
            <summary>尝试获取目标值</summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakReference`1.op_Implicit(NewLife.WeakReference{`0})~`0">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakReference`1.op_Implicit(`0)~NewLife.WeakReference{`0}">
            <summary>类型转换</summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.WeakReference`1.Target">
            <summary>目标引用对象</summary>
        </member>
        <member name="T:NewLife.Messaging.NullMessage">
            <summary>空消息。最短消息，只占一个字节</summary>
        </member>
        <member name="M:NewLife.Messaging.NullMessage.OnWrite(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>已重载。</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="M:NewLife.Messaging.NullMessage.OnRead(System.IO.Stream,NewLife.Serialization.RWKinds)">
            <summary>已重载。</summary>
            <param name="stream">数据流</param>
            <param name="rwkind">序列化类型</param>
        </member>
        <member name="P:NewLife.Messaging.NullMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="T:NewLife.Messaging.ExceptionMessage">
            <summary>异常消息</summary>
        </member>
        <member name="M:NewLife.Messaging.ExceptionMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.ExceptionMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.ExceptionMessage.Value">
            <summary>异常对象</summary>
        </member>
        <member name="T:NewLife.IO.StreamHttpHandler">
            <summary>数据流Http处理器。可以在web.config中配置一个处理器指向该类。</summary>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.OnProcess(System.Web.HttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.GetName(System.Web.HttpContext)">
            <summary>从Http上下文获取数据流总线名称</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.GetStream(System.Web.HttpContext)">
            <summary>从Http上下文获取数据流</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.ToHex(System.Byte[])">
            <summary>加密</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.FromHex(System.String)">
            <summary>解密</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.StreamHttpHandler.IsReusable">
            <summary>是否可以重用</summary>
        </member>
        <member name="T:NewLife.Reflection.Action`2">
            <summary>两个参数</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
        </member>
        <member name="T:NewLife.Reflection.Action`3">
            <summary>三个参数</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="T:NewLife.Reflection.Action`4">
            <summary>四个参数</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="T:NewLife.Compression.ZipEntry">
            <summary>Zip实体。包含文件头信息和文件位置</summary>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.OnDispose(System.Boolean)">
            <summary>释放资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.Extract(System.String,System.Boolean)">
            <summary>解压缩</summary>
            <param name="path">目标路径</param>
            <param name="overrideExisting">是否覆盖已有文件</param>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.Extract(System.IO.Stream)">
            <summary>解压缩</summary>
            <param name="outStream">目标数据流</param>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.Create(System.String,System.String,System.Nullable{System.Boolean})">
            <summary>从文件创建实体</summary>
            <param name="fileName"></param>
            <param name="entryName"></param>
            <param name="stored"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.Create(System.IO.Stream,System.String,System.Boolean,System.Boolean)">
            <summary>从数据流创建实体</summary>
            <param name="stream"></param>
            <param name="entryName"></param>
            <param name="stored"></param>
            <param name="embedFileData"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.CopyFromDirEntry(NewLife.Compression.ZipEntry)">
            <summary>复制DirEntry专属的字段</summary>
            <param name="entry"></param>
        </member>
        <member name="M:NewLife.Compression.ZipEntry.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.Signature">
            <summary>签名</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.VersionMadeBy">
            <summary>系统类型</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.VersionNeeded">
            <summary>解压缩所需要的版本</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.BitField">
            <summary>标识位</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.CompressionMethod">
            <summary>压缩方法</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.LastModified">
            <summary>最后修改时间</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.Crc">
            <summary>CRC校验</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.CompressedSize">
            <summary>压缩后大小</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.UncompressedSize">
            <summary>原始大小</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.FileNameLength">
            <summary>文件名长度</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.ExtraFieldLength">
            <summary>扩展数据长度</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.CommentLength">
            <summary>注释长度</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.DiskNumber">
            <summary>分卷号。</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.InternalFileAttrs">
            <summary>内部文件属性</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.ExternalFileAttrs">
            <summary>扩展文件属性</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.RelativeOffsetOfLocalHeader">
            <summary>文件头相对位移</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.FileName">
            <summary>文件名，如果是目录，则以/结束</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.ExtraField">
            <summary>扩展字段</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.Comment">
            <summary>注释</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.IsDirectory">
            <summary>是否目录</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.DataSource">
            <summary>数据源</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.StreamDataSource.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.StreamDataSource.Offset">
            <summary>位移</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.StreamDataSource.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.StreamDataSource.IsCompressed">
            <summary>是否被压缩</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.ArrayDataSource.Buffer">
            <summary>字节数组</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.ArrayDataSource.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.FileDataSource.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.Compression.ZipEntry.FileDataSource.Stream">
            <summary>数据流</summary>
        </member>
        <member name="T:NewLife.Collections.SingleListNode`1">
            <summary>单向链表节点</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor(`0)">
            <summary>使用一个对象初始化一个节点</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor(`0,NewLife.Collections.SingleListNode{`0})">
            <summary>使用一个对象和下一个节点初始化一个节点</summary>
            <param name="item"></param>
            <param name="next"></param>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.Contain(`0)">
            <summary>在单向链表中查找指定项</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.Remove(`0)">
            <summary>在单向链表中移除指定项</summary>
            <param name="item">指定项</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.SingleListNode`1.Item">
            <summary>元素</summary>
        </member>
        <member name="P:NewLife.Collections.SingleListNode`1.Next">
            <summary>下一个节点</summary>
        </member>
        <member name="T:NewLife.Xml.XmlWriterX">
            <summary>Xml写入器</summary>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteLiteral(System.String)">
            <summary>输出字符串字面值,不做编码处理</summary>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.Write(System.DateTime)">
            <summary>将一个时间日期写入</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteValue(System.Object,System.Type)">
            <summary>写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteObjectType(System.Type)">
            <summary>写对象类型</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入字典项 </summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举项</summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入枚举数据，复杂类型使用委托方法进行处理</summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>已重载。写入文档的开头和结尾</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteMember(System.String,System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入对象成员</summary>
            <param name="name">成员名字</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteObjRefIndex(System.Int32)">
            <summary>写对象引用计数</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteUnKnown(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.Flush">
            <summary>刷新缓存中的数据</summary>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteLengths(System.String)">
            <summary>写入长度。多维数组用</summary>
            <param name="lengths"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.Backup">
            <summary>备份当前环境，用于临时切换数据流等</summary>
            <returns>本次备份项集合</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.Restore">
            <summary>恢复最近一次备份</summary>
            <returns>本次还原项集合</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteSerializable(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>写入实现了可序列化接口的对象</summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型，如果type等于DataTable，需设置DataTable的名称</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnGetMembers(System.Type,System.Object)">
            <summary>获取需要序列化的成员（属性或字段）。在序列化为属性时，需要排列成员，先拍属性，否则会有问题</summary>
            <param name="type">指定类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.IsAttributeType(System.Type)">
            <summary>是否可以作为属性写入Xml的类型</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Xml.XmlWriterX.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Xml.XmlWriterX.Stream">
            <summary>数据流。更改数据流后，重置Writer为空，以使用新的数据流</summary>
        </member>
        <member name="P:NewLife.Xml.XmlWriterX.RootName">
            <summary>根元素名</summary>
        </member>
        <member name="T:NewLife.Xml.XmlHelper">
            <summary>Xml辅助类</summary>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object)">
            <summary>序列化为Xml</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.Text.Encoding,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>序列化为Xml字符串</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="encoding">编码</param>
            <param name="prefix">前缀</param>
            <param name="ns">命名空间，设为0长度字符串可去掉默认命名空间xmlns:xsd和xmlns:xsi</param>
            <param name="includeDeclaration">是否包含Xml声明</param>
            <param name="attachCommit">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.IO.Stream,System.Text.Encoding,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>序列化为Xml数据流</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="stream">目标数据流</param>
            <param name="encoding">编码</param>
            <param name="prefix">前缀</param>
            <param name="ns">命名空间，设为0长度字符串可去掉默认命名空间xmlns:xsd和xmlns:xsi</param>
            <param name="includeDeclaration">是否包含Xml声明 &lt;?xml version="1.0" encoding="utf-8"?&gt;</param>
            <param name="attachCommit">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFile(System.Object,System.String,System.Text.Encoding,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>序列化为Xml文件</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="file">目标Xml文件</param>
            <param name="encoding">编码</param>
            <param name="prefix">前缀</param>
            <param name="ns">命名空间，设为0长度字符串可去掉默认命名空间xmlns:xsd和xmlns:xsi</param>
            <param name="includeDeclaration">是否包含Xml声明 &lt;?xml version="1.0" encoding="utf-8"?&gt;</param>
            <param name="attachCommit">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.String)">
            <summary>字符串转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="xml">Xml字符串</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.String,System.Type)">
            <summary>字符串转为Xml实体对象</summary>
            <param name="xml">Xml字符串</param>
            <param name="type">实体类型</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.IO.Stream,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="stream">数据流</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.IO.Stream,System.Type,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <param name="stream">数据流</param>
            <param name="type">实体类型</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFileEntity``1(System.String,System.Text.Encoding)">
            <summary>Xml文件转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="file">Xml文件</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.TrimPreamble(System.Text.Encoding)">
            <summary>删除字节序，硬编码支持utf-8、utf-32、Unicode三种</summary>
            <param name="encoding">原始编码</param>
            <returns>删除字节序后的编码</returns>
        </member>
        <member name="F:NewLife.Xml.XmlHelper.typeHasCommit">
            <summary>是否拥有注释</summary>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.AttachCommit(System.Xml.XmlNode,System.Type)">
            <summary>附加注释</summary>
            <param name="node"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlDictionary(System.String)">
            <summary>简单Xml转为字符串字典</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>字符串字典转为Xml</summary>
            <param name="dic"></param>
            <param name="rootName"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Common.IdentityCard">
            <summary>身份证</summary>
        </member>
        <member name="M:NewLife.Common.IdentityCard.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Common.IdentityCard.Valid(System.String)">
            <summary>验证身份证是否合法</summary>
            <param name="card"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.IdentityCard.Parse(System.String)">
            <summary>使用身份证号码初始化</summary>
            <param name="card"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Common.IdentityCard.Birthday">
            <summary>生日</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.Sex">
            <summary>性别</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.IsOld">
            <summary>是否15位旧卡</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.AreaNum">
            <summary>地区编码</summary>
        </member>
        <member name="T:NewLife.Common.IdentityCard.SexType">
            <summary>性别</summary>
        </member>
        <member name="F:NewLife.Common.IdentityCard.SexType.Man">
            <summary>男</summary>
        </member>
        <member name="F:NewLife.Common.IdentityCard.SexType.Woman">
            <summary>女</summary>
        </member>
        <member name="T:NewLife.Reflection.EmitHelper">
            <summary>动态生成代码Emit助手。仅提供扩展功能，不封装基本功能</summary>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldc_I4(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Ldc_I4指令的整数推送，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldarg(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Ldarg指令的参数加载，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Stloc指令的弹栈，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Ldloc指令的压栈，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldfld(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>查找对象中其引用当前位于计算堆栈的字段的值。</summary>
            <param name="IL">指令</param>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldind(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>间接加载到计算堆栈</summary>
            <param name="IL">指令</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stind(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>间接加载到计算堆栈</summary>
            <param name="IL">指令</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldelem_Ref(System.Reflection.Emit.ILGenerator)">
            <summary>将位于指定数组索引处的包含对象引用的元素作为 O 类型（对象引用）加载到计算堆栈的顶部。</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stelem_Ref(System.Reflection.Emit.ILGenerator)">
            <summary>用计算堆栈上的对象 ref 值（O 类型）替换给定索引处的数组元素。</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.CastFromObject(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>把一个类型转为指定类型，值类型装箱，引用类型直接Cast</summary>
            <param name="IL">指令</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.BoxIfValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>装箱</summary>
            <param name="IL">指令</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Call(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            <summary>调用</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldnull(System.Reflection.Emit.ILGenerator)">
            <summary>加载空</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ret(System.Reflection.Emit.ILGenerator)">
            <summary>返回</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>创建值类型，对象位于栈上</summary>
            <param name="IL">指令</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewArray(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>创建数组，参数必须是Object[]</summary>
            <param name="IL">指令</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewObj(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
            <summary>创建对象</summary>
            <param name="IL">指令</param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.CreateLocalsForByRefParams(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>为引用参数声明本地变量</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.AssignByRefParamsToArray(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>将引用参数赋值到数组</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParamsOrLocalsToStack(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>将参数压栈</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParams(System.Reflection.Emit.ILGenerator,System.Int32,System.Reflection.MethodBase)">
            <summary>将指定参数位置的数组参数按照方法参数要求压栈</summary>
            <param name="IL">指令</param>
            <param name="paramIndex"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParams(System.Reflection.Emit.ILGenerator,System.Int32,System.Type[])">
            <summary>将指定参数位置的数组参数一个个压栈</summary>
            <param name="IL">指令</param>
            <param name="paramIndex"></param>
            <param name="paramTypes"></param>
            <returns></returns>
        </member>
        <member name="T:System.AttributeX">
            <summary>特性辅助类</summary>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributes``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取自定义特性，带有缓存功能，避免因.Net内部GetCustomAttributes没有缓存而带来的损耗</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取自定义属性</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributes``1(System.Reflection.Assembly)">
            <summary>获取自定义属性，带有缓存功能，避免因.Net内部GetCustomAttributes没有缓存而带来的损耗</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttribute``1(System.Reflection.Assembly)">
            <summary>获取自定义属性</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributeValue``2(System.Reflection.Assembly)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributeValue``2(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="inherit">是否递归</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IServer">
            <summary>服务接口。</summary>
            <remarks>服务代理XAgent可以附加代理实现了IServer接口的服务。</remarks>
        </member>
        <member name="M:NewLife.Model.IServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Model.IServer.Stop">
            <summary>停止</summary>
        </member>
        <member name="T:NewLife.Messaging.GroupMessage">
            <summary>组消息</summary>
            <remarks>
            对于超长消息，可拆分为多个组消息进行传输，然后在目的地重组。
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.GroupMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.GroupMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.GroupMessage.Identity">
            <summary>唯一标识</summary>
        </member>
        <member name="P:NewLife.Messaging.GroupMessage.Index">
            <summary>在组中的索引位置</summary>
        </member>
        <member name="P:NewLife.Messaging.GroupMessage.Count">
            <summary>分组数</summary>
        </member>
        <member name="P:NewLife.Messaging.GroupMessage.Data">
            <summary>数据</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageGroup">
            <summary>消息组。</summary>
            <remarks>
            20120421，连续两天半，完成消息分片组装算法，尽可能的让分片占用最大大小。
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.MessageGroup.Add(NewLife.Messaging.GroupMessage)">
            <summary>添加组消息，返回是否已收到所有组消息。</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageGroup.GetStream">
            <summary>获取整个数据流</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageGroup.GetMessage">
            <summary>获取整个消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageGroup.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.MessageGroup.Identity">
            <summary>唯一标识</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageGroup.Items">
            <summary>消息集合</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageGroup.First">
            <summary>第一个组消息，上面有总记录数</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageGroup.Total">
            <summary>总的组消息数</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageGroup.Count">
            <summary>组消息个数</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageKind">
            <summary>消息类型</summary>
            <remarks>定义一些常用的消息类型，其它用户自定义类型用数字代替</remarks>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Null">
            <summary>空消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Data">
            <summary>指定长度的字节数据消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.String">
            <summary>字符串</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Entity">
            <summary>指定类型的实体对象消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Entities">
            <summary>指定类型的实体对象数组消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Exception">
            <summary>异常消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Compression">
            <summary>经过压缩的消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Method">
            <summary>远程方法调用消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Group">
            <summary>组消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.Channel">
            <summary>通道消息</summary>
        </member>
        <member name="F:NewLife.Messaging.MessageKind.UserDefine">
            <summary>用户自定义消息在此基础上增加</summary>
        </member>
        <member name="T:NewLife.IO.StreamReaderX">
            <summary>增强的数据流读取器</summary>
            <remarks>
            StreamReader太恶心了，自动把流给关闭了，还没有地方设置。
            </remarks>
        </member>
        <member name="M:NewLife.IO.StreamReaderX.#ctor(System.IO.Stream)">
            <summary>为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例。</summary>
            <param name="stream">要读取的流。</param>
            <exception cref="T:System.ArgumentException"><paramref name="stream" /> 不支持读取。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.IO.StreamReaderX.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>用指定的字符编码为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的一个新实例。</summary>
            <param name="stream">要读取的流。</param>
            <param name="encoding">要使用的字符编码。</param>
            <exception cref="T:System.ArgumentException"><paramref name="stream" /> 不支持读取。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 null。</exception>
        </member>
        <member name="M:NewLife.IO.StreamReaderX.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定的字符编码、字节顺序标记检测选项和缓冲区大小。</summary>
            <param name="stream">要读取的流。</param>
            <param name="encoding">要使用的字符编码。</param>
            <param name="closable">是否关闭数据流。</param>
            <exception cref="T:System.ArgumentException">流不支持读取。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 null。</exception>
        </member>
        <member name="P:NewLife.IO.StreamReaderX.Closable">
            <summary>是否在最后关闭流</summary>
        </member>
        <member name="P:NewLife.IO.StreamReaderX.CharPosition">
            <summary>字符位置。因为涉及字符编码，所以跟流位置可能不同。对于ASCII编码没有问题。</summary>
        </member>
        <member name="T:NewLife.Collections.LockStack`1">
            <summary>基于lock的安全栈</summary>
            <remarks>
            理论上性能最差，但实际测试发现，似乎比InterlockedStack要好点。
            重点是它安全可信。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.LockStack`1.Push(`0)">
            <summary>向栈压入一个对象</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.LockStack`1.Pop">
            <summary>从栈中弹出一个对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.LockStack`1.TryPop(`0@)">
            <summary>尝试从栈中弹出一个对象</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.LockStack`1.Peek">
            <summary>获取栈顶对象，不弹栈</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.LockStack`1.TryPeek(`0@)">
            <summary>尝试获取栈顶对象，不弹栈</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.LockStack`1.GetEnumerator">
            <summary>获取枚举器</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Xml.XmlEntity`1">
            <summary>Xml实体基类</summary>
            <remarks>主要提供数据实体和XML文件之间的映射功能</remarks>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.Load(System.String)">
            <summary>从一段XML文本中加载对象</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.LoadFile(System.String)">
            <summary>从一个XML文件中加载对象</summary>
            <param name="filename">若为空，则默认为类名加xml后缀</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.ToXml">
            <summary>输出XML</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.ToInnerXml">
            <summary>输出内部XML</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.Save(System.String)">
            <summary>保存到文件中</summary>
            <param name="filename">若为空，则默认为类名加xml后缀</param>
        </member>
        <member name="T:NewLife.Reflection.FastIndexAccessor">
            <summary>快速索引器接口的默认实现</summary>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.GetValue(System.Object,System.String)">
            <summary>获取目标对象指定属性字段的值</summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.TryGetValue(System.Object,System.String,System.Object@)">
            <summary>尝试获取目标对象指定属性字段的值，返回是否成功</summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.GetValue``1(System.String)">
            <summary>获取目标对象指定属性字段的值</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取目标对象指定属性字段的值，返回是否成功</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.SetValue(System.Object,System.String,System.Object)">
            <summary>设置目标对象指定属性字段的值</summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.TrySetValue(System.Object,System.String,System.Object)">
            <summary>尝试设置目标对象指定属性字段的值，返回是否成功</summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FastIndexAccessor.Item(System.String)">
            <summary>
            获取/设置 字段值。
            一个索引，反射实现。
            派生实体类可重写该索引，以避免发射带来的性能损耗
            </summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.CodeTimer">
            <summary>代码性能计时器</summary>
            <remarks>参考了老赵（http://www.cnblogs.com/jeffreyzhao/archive/2009/03/10/codetimer.html）和eaglet（http://www.cnblogs.com/eaglet/archive/2009/03/10/1407791.html）两位的作品</remarks>
            <remarks>为了保证性能比较的公平性，采用了多种指标，并使用计时器重写等手段来避免各种不必要的损耗</remarks>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32,System.Action{System.Int32},System.Boolean)">
            <summary>计时</summary>
            <param name="times">次数</param>
            <param name="action">需要计时的委托</param>
            <param name="needTimeOne">是否需要预热</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeLine(System.String,System.Int32,System.Action{System.Int32},System.Boolean)">
            <summary>计时，并用控制台输出行</summary>
            <param name="title">标题</param>
            <param name="times">次数</param>
            <param name="action">需要计时的委托</param>
            <param name="needTimeOne">是否需要预热</param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ShowHeader(System.String)">
            <summary>显示头部</summary>
            <param name="title"></param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time">
            <summary>计时核心方法，处理进程和线程优先级</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeTrue">
            <summary>真正的计时</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeOne">
            <summary>执行一次迭代，预热所有方法</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Init">
            <summary>迭代前执行，计算时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32)">
            <summary>每一次迭代，计算时间</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Finish">
            <summary>迭代后执行，计算时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ToString">
            <summary>已重载。输出依次分别是：执行时间、CPU线程时间、时钟周期、GC代数</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Action">
            <summary>迭代方法，如不指定，则使用Time(int index)</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ShowProgress">
            <summary>是否显示控制台进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Index">
            <summary>进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.CpuCycles">
            <summary>CPU周期</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ThreadTime">
            <summary>线程时间，单位是100ns，除以10000转为ms</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Gen">
            <summary>GC代数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Elapsed">
            <summary>执行时间</summary>
        </member>
        <member name="T:NewLife.Log.TextFileLog">
            <summary>文本文件日志类。提供向文本文件写日志的能力</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Create(System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Log.TextFileLog.isFirst">
            <summary>是否当前进程的第一次写日志</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.InitLog">
            <summary>初始化日志记录文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.CloseWriter(System.Object)">
            <summary>停止日志</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.PerformWriteLog(NewLife.Log.WriteLogEventArgs)">
            <summary>使用线程池线程异步执行日志写入动作</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Write(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Write(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteLine(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteException(System.Exception)">
            <summary>输出异常日志</summary>
            <param name="ex">异常信息</param>
        </member>
        <member name="P:NewLife.Log.TextFileLog.FilePath">
            <summary>文件路径</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.LogPath">
            <summary>日志目录</summary>
        </member>
        <member name="T:NewLife.WeakEventHandler`1">
            <summary>弱引用事件</summary>
            <remarks>
            很多绑定事件的场合，并不适合取消绑定，这就造成了事件资源无法得到回收。
            更加麻烦的是，事件本身除了包含事件处理方法外，还会包含目标对象，也就导致目标对象无法得到释放。
            弱引用事件的原理是把目标对象与事件处理方法分拆开来，使用弱引用来引用目标对象，保证目标对象能够得到有效的释放。
            触发弱引用事件时，首先判断目标对象是否可用，因为其可能已经被GC回收，然后再通过快速访问方法调用事件处理方法。
            也许有人会问，如果目标对象不可用怎么办？岂不是无法执行事件处理方法了？
            我们换一个角度来看，既然目标对象都已经不存在了，它绑定的事件自然也就无需过问了！
            </remarks>
            <typeparam name="TEventArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Method">
            <summary>委托方法</summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Handler">
            <summary>经过包装的新的委托</summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.UnHandler">
            <summary>取消注册的委托</summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Once">
            <summary>是否只使用一次，如果只使用一次，执行委托后马上取消注册</summary>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.#ctor(System.EventHandler{`0},System.Action{System.EventHandler{`0}},System.Boolean)">
            <summary>使用事件处理器、取消注册回调、是否一次性事件来初始化</summary>
            <param name="handler"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Invoke(System.Object,`0)">
            <summary>调用委托</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.op_Implicit(NewLife.WeakEventHandler{`0})~System.EventHandler{`0}">
            <summary>把弱引用事件处理器转换为普通事件处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Combine(System.EventHandler{`0}@)">
            <summary>绑定</summary>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Remove(System.EventHandler{`0}@,System.EventHandler{`0})">
            <summary>移除</summary>
            <param name="handler"></param>
            <param name="value"></param>
        </member>
        <member name="T:NewLife.Messaging.MethodMessage">
            <summary>远程方法调用消息</summary>
            <remarks>
            根据方法名<see cref="P:NewLife.Messaging.MethodMessage.Name"/>在类型<see cref="P:NewLife.Messaging.MethodMessage.Type"/>中找到方法，如果有多个签名，还得根据参数数组<see cref="P:NewLife.Messaging.MethodMessage.Parameters"/>来选择。
            仅支持无返回或单一返回，不支持out/ref等参数。
            
            在服务端，通过调用消息的<see cref="M:NewLife.Messaging.MethodMessage.Invoke"/>方法执行调用。
            如有异常，返回异常消息；
            如返回空，返回空消息；
            否则返回实体消息<see cref="T:NewLife.Messaging.EntityMessage"/>
            </remarks>
        </member>
        <member name="M:NewLife.Messaging.MethodMessage.Create(System.String,System.Object[])">
            <summary>根据包括类型和方法名的完整方法名，以及参数，创建方法消息</summary>
            <param name="fullMethodName">完整方法名</param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MethodMessage.Invoke">
            <summary>处理消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MethodMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.MethodMessage.Kind">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Messaging.MethodMessage.Type">
            <summary>实体类型。可以是接口或抽象类型（要求对象容器能识别）</summary>
        </member>
        <member name="P:NewLife.Messaging.MethodMessage.TypeName">
            <summary>实体类型名。可以是接口或抽象类型（要求对象容器能识别）</summary>
        </member>
        <member name="P:NewLife.Messaging.MethodMessage.Name">
            <summary>方法名</summary>
        </member>
        <member name="P:NewLife.Messaging.MethodMessage.Parameters">
            <summary>参数数组</summary>
        </member>
        <member name="P:NewLife.Messaging.MethodMessage.Method">
            <summary>方法对象</summary>
        </member>
        <member name="T:System.BitHelper">
            <summary>数据位助手</summary>
        </member>
        <member name="M:System.BitHelper.SetBit(System.UInt16,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value"></param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.SetBits(System.UInt16,System.Int32,System.Int32,System.UInt16)">
            <summary>设置数据位</summary>
            <param name="value"></param>
            <param name="position"></param>
            <param name="length"></param>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.SetBit(System.Byte,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value"></param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.GetBit(System.UInt16,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.GetBits(System.UInt16,System.Int32,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value"></param>
            <param name="position"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.GetBit(System.Byte,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.InterlockedStack`1">
            <summary>先进先出LIFO的原子栈结构，采用CAS保证线程安全。利用单链表实现。</summary>
            <remarks>
            注意：<see cref="M:NewLife.Collections.InterlockedStack`1.Push(`0)"/>、<see cref="M:NewLife.Collections.InterlockedStack`1.TryPop(`0@)"/>、<see cref="M:NewLife.Collections.InterlockedStack`1.Pop"/>、<see cref="M:NewLife.Collections.InterlockedStack`1.TryPeek(`0@)"/>、<see cref="M:NewLife.Collections.InterlockedStack`1.Peek"/>是重量级线程安全代码，不要随意更改。
            
            增加自由节点链表，避免频繁分配节点带来的GC压力。
            
            经过测试，对象数量在万级以上时，性能急剧下降！
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:NewLife.Collections.InterlockedStack`1.Top">
            <summary>栈顶</summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Push(`0)">
            <summary>向栈压入一个对象</summary>
            <remarks>重点解决多线程环境下资源争夺以及使用lock造成性能损失的问题</remarks>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Pop">
            <summary>从栈中弹出一个对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.TryPop(`0@)">
            <summary>尝试从栈中弹出一个对象</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Peek">
            <summary>获取栈顶对象，不弹栈</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.TryPeek(`0@)">
            <summary>尝试获取栈顶对象，不弹栈</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Collections.InterlockedStack`1.FreeTop">
            <summary>自由节点头部</summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Clear">
            <summary>清空</summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.ToArray">
            <summary>转为数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.GetEnumerator">
            <summary>获取枚举器</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.InterlockedStack`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="P:NewLife.Collections.InterlockedStack`1.UseNodePool">
            <summary>是否使用节点池。采用节点池可以避免分配节点造成的GC压力，但是会让性能有所降低。</summary>
        </member>
        <member name="T:NewLife.Collections.ObjectPoolTest`1">
            <summary>对象池测试</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ObjectPoolTest`1.Start">
            <summary>开始</summary>
        </member>
        <member name="T:NewLife.Collections.ObjectPool`1">
            <summary>对象池。采用原子栈设计，避免锁资源的争夺。</summary>
            <remarks>
            经过测试，对象数量在万级以上时，性能下降很快！
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.#ctor">
            <summary>实例化一个对象池</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1.OnCreate">
            <summary>对象创建委托。在对象池内对象不足时调用，如未设置，则调用类型的默认构造函数创建对象。</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Push(`0)">
            <summary>归还</summary>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Pop">
            <summary>借出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Create">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Stock">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Max">
            <summary>最大缓存数。默认1000，超过后将启用定时器来清理</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.StockCount">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.NotStockCount">
            <summary>不在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.FreeCount">
            <summary>被释放的对象数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.CreateCount">
            <summary>创建数</summary>
        </member>
        <member name="T:NewLife.Web.SystemStartModule">
            <summary>系统启动模块</summary>
        </member>
        <member name="M:NewLife.Web.SystemStartModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.SystemStartModule.CheckStarting">
            <summary>检查系统是否启动中，如果启动中，则显示进度条</summary>
        </member>
        <member name="T:NewLife.Security.Crc32">
             <summary>CRC32校验</summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:NewLife.Security.Crc32.crc">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Int32)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验</summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验</summary>
            <param name="stream"></param>
            <param name="count"></param>
        </member>
        <member name="P:NewLife.Security.Crc32.Value">
            <summary>校验值</summary>
        </member>
        <member name="T:NewLife.Reflection.FieldInfoX">
            <summary>快速字段访问</summary>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.Create(System.Reflection.FieldInfo)">
            <summary>创建</summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.Create(System.Type,System.String)">
            <summary>创建</summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue(System.Object)">
            <summary>取值</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue(System.Object,System.Object)">
            <summary>赋值</summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue``1(System.Object,System.String)">
            <summary>静态快速取值。若字段不存在，会抛出异常。不确定字段是否存在时，建议使用Create方法</summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue``2(System.String)">
            <summary>快速获取静态字段。若字段不存在，会抛出异常。不确定字段是否存在时，建议使用Create方法</summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue(System.Object,System.String,System.Object)">
            <summary>静态快速赋值。若字段不存在，会抛出异常。不确定字段是否存在时，建议使用Create方法</summary>
            <param name="target"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue``1(System.String,System.Object)">
            <summary>快速设置静态字段。若字段不存在，会抛出异常。不确定字段是否存在时，建议使用Create方法</summary>
            <typeparam name="TTarget"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.op_Implicit(NewLife.Reflection.FieldInfoX)~System.Reflection.FieldInfo">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.op_Implicit(System.Reflection.FieldInfo)~NewLife.Reflection.FieldInfoX">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.Field">
            <summary>目标字段</summary>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.GetHandler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.SetHandler">
            <summary>快速调用委托，延迟到首次使用才创建</summary>
        </member>
        <member name="T:NewLife.IO.ReadWriteMemoryStream">
            <summary>读写流，继承自内存流，读写指针分开</summary>
            <remarks>
            注意资源锁，读写不可同时进行，会出现抢锁的情况。
            </remarks>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.SeekForWrite(System.Int64,System.IO.SeekOrigin)">
            <summary>已重载。</summary>
            <param name="offset"></param>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.ResetLength">
            <summary>重设长度，</summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>已重载。</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.ReadByte">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>已重载。</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.WriteByte(System.Byte)">
            <summary>已重载。</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Dispose(System.Boolean)">
            <summary>资源释放，关闭事件量</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.ReadTimeout">
            <summary>获取或设置一个值（以毫秒为单位），该值确定流在超时前尝试读取多长时间。</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.PositionForWrite">
            <summary>写位置</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.MaxLength">
            <summary>最大长度，超过次长度时清空缓冲区</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.AvailableData">
            <summary>可用数据</summary>
        </member>
        <member name="T:NewLife.Serialization.RWService">
            <summary>读写器服务。将来可以改为对象容器支持</summary>
        </member>
        <member name="T:NewLife.Serialization.RWKinds">
            <summary>序列化种类</summary>
        </member>
        <member name="F:NewLife.Serialization.RWKinds.Binary">
            <summary>二进制</summary>
        </member>
        <member name="F:NewLife.Serialization.RWKinds.Xml">
            <summary>Xml</summary>
        </member>
        <member name="F:NewLife.Serialization.RWKinds.Json">
            <summary>Json</summary>
        </member>
        <member name="F:NewLife.Serialization.RWKinds.NameValue">
            <summary>名值</summary>
        </member>
        <member name="T:NewLife.Serialization.ReflectMemberInfo">
            <summary>反射成员信息</summary>
        </member>
        <member name="M:NewLife.Serialization.ReflectMemberInfo.#ctor(System.Reflection.MemberInfo)">
            <summary>实例化</summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Serialization.ReflectMemberInfo.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Mix">
            <summary>快速反射</summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Item(System.Object)">
            <summary>对目标对象取值赋值</summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:System.IOHelper">
            <summary>IO工具类</summary>
        </member>
        <member name="M:System.IOHelper.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流</param>
        </member>
        <member name="M:System.IOHelper.Decompress(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流</param>
        </member>
        <member name="M:System.IOHelper.Compress(System.Byte[])">
            <summary>压缩字节数组</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Decompress(System.Byte[])">
            <summary>解压缩字节数组</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32,System.Int32)">
            <summary>复制数据流</summary>
            <param name="src">源数据流</param>
            <param name="des">目的数据流</param>
            <param name="bufferSize">缓冲区大小，也就是每次复制的大小</param>
            <param name="max">最大复制字节数</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:System.IOHelper.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>复制数组</summary>
            <param name="src">源数组</param>
            <param name="offset">起始位置</param>
            <param name="count">复制字节数</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:System.IOHelper.ReadBytes(System.IO.Stream,System.Int64)">
            <summary>流转为字节数组</summary>
            <param name="stream">数据流</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadTo(System.IO.Stream,System.Byte[],System.Int64,System.Int64)">
            <summary>从数据流中读取字节数组，直到遇到指定字节数组</summary>
            <param name="stream">数据流</param>
            <param name="buffer">字节数组</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="length">字节数组中的查找长度</param>
            <returns>未找到时返回空，0位置范围大小为0的字节数组</returns>
        </member>
        <member name="M:System.IOHelper.ReadTo(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>从数据流中读取字节数组，直到遇到指定字节数组</summary>
            <param name="stream">数据流</param>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadLine(System.IO.Stream,System.Text.Encoding)">
            <summary>从数据流中读取一行，直到遇到换行</summary>
            <param name="stream">数据流</param>
            <param name="encoding"></param>
            <returns>未找到返回null，0位置返回String.Empty</returns>
        </member>
        <member name="M:System.IOHelper.ToStr(System.IO.Stream,System.Text.Encoding)">
            <summary>流转换为字符串</summary>
            <param name="stream">目标流</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.IndexOf(System.IO.Stream,System.Byte[],System.Int64,System.Int64)">
            <summary>在数据流中查找字节数组的位置，流指针会移动到结尾</summary>
            <param name="stream">数据流</param>
            <param name="buffer">字节数组</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="length">字节数组中的查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.IndexOf(System.Byte[],System.Byte[],System.Int64,System.Int64)">
            <summary>在字节数组中查找另一个字节数组的位置，不存在则返回-1</summary>
            <param name="source">字节数组</param>
            <param name="buffer">另一个字节数组</param>
            <param name="offset">偏移</param>
            <param name="length">查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.IndexOf(System.Byte[],System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>在字节数组中查找另一个字节数组的位置，不存在则返回-1</summary>
            <param name="source">字节数组</param>
            <param name="start">源数组起始位置</param>
            <param name="count">查找长度</param>
            <param name="buffer">另一个字节数组</param>
            <param name="offset">偏移</param>
            <param name="length">查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.CompareTo(System.Byte[],System.Byte[])">
            <summary>比较两个字节数组大小。相等返回0，不等则返回不等的位置，如果位置为0，则返回1。</summary>
            <param name="source"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.CompareTo(System.Byte[],System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>比较两个字节数组大小。相等返回0，不等则返回不等的位置，如果位置为0，则返回1。</summary>
            <param name="source"></param>
            <param name="start"></param>
            <param name="count"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.StartsWith(System.IO.Stream,System.Byte[])">
            <summary>一个数据流是否以另一个数组开头。如果成功，指针移到目标之后，否则保持指针位置不变。</summary>
            <param name="source"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.EndsWith(System.IO.Stream,System.Byte[])">
            <summary>一个数据流是否以另一个数组结尾。如果成功，指针移到目标之后，否则保持指针位置不变。</summary>
            <param name="source"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.StartsWith(System.Byte[],System.Byte[])">
            <summary>一个数组是否以另一个数组开头</summary>
            <param name="source"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.EndsWith(System.Byte[],System.Byte[])">
            <summary>一个数组是否以另一个数组结尾</summary>
            <param name="source"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ModelExtension">
            <summary>模型扩展</summary>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetService``1(System.IServiceProvider)">
            <summary>获取指定类型的服务对象</summary>
            <typeparam name="T"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Compression.ZipException">
            <summary>Zip异常</summary>
        </member>
        <member name="M:NewLife.Compression.ZipException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Compression.ZipException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Compression.ZipException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Compression.ZipException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Compression.ZipException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Compression.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>初始化</summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:MyExtensions.PinYinConverter">
            <summary>汉字拼音转换类</summary>
        </member>
        <member name="F:MyExtensions.PinYinConverter.otherChinese">
            <summary>二级汉字数组</summary>
        </member>
        <member name="F:MyExtensions.PinYinConverter.otherPinYin">
            <summary>
            二级汉字对应拼音数组
            </summary>
        </member>
        <member name="M:MyExtensions.PinYinConverter.GetFirst(System.Char)">
            <summary>取拼音第一个字段</summary>        
            <param name="ch"></param>        
            <returns></returns>        
        </member>
        <member name="M:MyExtensions.PinYinConverter.GetFirst(System.String)">
            <summary>取拼音第一个字段</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:MyExtensions.PinYinConverter.Get(System.Char)">
            <summary>获取单字拼音</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:MyExtensions.PinYinConverter.Get(System.String)">
            <summary>把汉字转换成拼音(全拼)</summary>
            <param name="str">汉字字符串</param>
            <returns>转换后的拼音(全拼)字符串</returns>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2">
            <summary>字典缓存。当指定键的缓存项不存在时，调用委托获取值，并写入缓存。</summary>
            <remarks>常用匿名函数或者Lambda表达式作为委托。</remarks>
            <typeparam name="TKey">键类型</typeparam>
            <typeparam name="TValue">值类型</typeparam>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor">
            <summary>实例化一个字典缓存</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个字典缓存</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,NewLife.Reflection.Func{`0,`1})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,NewLife.Reflection.Func{`0,`1},System.Boolean)">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``1(`0,``0,NewLife.Reflection.Func{`0,``0,`1})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有一个泛型参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``1(`0,``0,NewLife.Reflection.Func{`0,``0,`1},System.Boolean)">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有一个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``2(`0,``0,``1,NewLife.Reflection.Func{`0,``0,``1,`1})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有两个泛型参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``2(`0,``0,``1,NewLife.Reflection.Func{`0,``0,``1,`1},System.Boolean)">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有两个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``3(`0,``0,``1,``2,NewLife.Reflection.Func{`0,``0,``1,``2,`1})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <typeparam name="TArg3">参数类型3</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="arg3">参数3</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有三个泛型参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``3(`0,``0,``1,``2,NewLife.Reflection.Func{`0,``0,``1,``2,`1},System.Boolean)">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <typeparam name="TArg3">参数类型3</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="arg3">参数3</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有三个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``4(`0,``0,``1,``2,``3,NewLife.Reflection.Func{`0,``0,``1,``2,``3,`1},System.Boolean)">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <typeparam name="TArg3">参数类型3</typeparam>
            <typeparam name="TArg4">参数类型4</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="arg3">参数3</param>
            <param name="arg4">参数4</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有三个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Collections.DictionaryCache`2.clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Add(`0,`1)">
            <summary></summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.ContainsKey(`0)">
            <summary></summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Remove(`0)">
            <summary></summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.TryGetValue(`0,`1@)">
            <summary></summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary></summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Clear">
            <summary></summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary></summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary></summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary></summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetEnumerator">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Expriod">
            <summary>过期时间。单位是秒，默认0秒，表示永不过期</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.ClearExpriod">
            <summary>过期清理时间，缓存项过期后达到这个时间时，将被移除缓存。单位是秒，默认0秒，表示不清理过期项</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Asynchronous">
            <summary>异步更新</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Item(`0)">
            <summary>重写索引器。取值时如果没有该项则返回默认值；赋值时如果已存在该项则覆盖，否则添加。</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Keys">
            <summary></summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Values">
            <summary></summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Count">
            <summary></summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.IsReadOnly">
            <summary></summary>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="F:NewLife.Collections.DictionaryCache`2.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
    </members>
</doc>
